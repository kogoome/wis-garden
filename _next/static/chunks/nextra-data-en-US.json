{"/inbox/42seoul":{"title":"'교수❌ 학비❌ 입학하면 오히려 월 100만 원씩 준다는 한국 학교 근황","data":{"":"","교수가-없는-학교에서는-어떻게-공부할까#교수가 없는 학교에서는 어떻게 공부할까?":"https://www.youtube.com/watch?v=0VrB9PoWa04※이 영상은 2023년 5월 17일에 방송된 ＜다큐멘터리K - 대학혁신, 1부. 왜 대학은 달라져야 하는가＞의 일부입니다. 그렇다면 대학혁신이 가야 할 길은 어디인가? 그 해답을 모색하기 위해 세계 최고의 혁신대학이라 불리는 미네르바 대학과 애리조나 주립대학에 혁신의 비결을 물었다…'"}},"/":{"title":"hello nextra","data":{"":""}},"/katalk/learn_lang":{"title":"언어를 습득하는 오직 한가지 방법","data":{"":"한줄요약 :\n불안없이 자신감과 흥미를 가지고 이해할 수 있는 인풋을 제공받는 것\n\n\n\n프로그래머들에게도 언어학습의 묘는 동일하게 작용되는것같더라구요. 사실상 대부분의 학습은 언어적 차원에서 이루어지기도 하구요. 새로운 기술문서를 학습하는과정에서도, 새로운 프로그래밍 언어를 배우는 과정에서도 아 이정도면 어느정도 이해한것같은데 싶다가도 막상 내면화가 부족해 영상에서 말한 침묵의 시간속에 있는 자신을 발견하곤 하는데, 조급해할 필요없이 이해 가능한 인풋을 더 찾아봐야겟다 라고 생각하게 됩니다.교육학에서는 행동주의 인지주의 구성주의등의 다른 관점이 있는데, 인지주의적 측면에서 교육자들이 학생의 특성에 맞추려고 이런 저런 다양한 시도를 했으나 정답을 찾아내지못한 선생님들을 위로하는듯 느껴졌습니다. 저도 한때 학생마다 적합한 학습의 방법이 조금씩 다르지 않을까 하는 학습유형론에 빠져있기도 했구요. 열심히 설명해줘도 침묵하는 학생들의 반응에서 좌절할 필요가 없다고. 또 학생 입장에서 나는 수업을 열심히 이해하고 듣는데 왜 아무것도 못하지 라는 좌절감에 불안해할필요가 없다고, 위로해주는것같았네요.사용해보지 않은 기술을 써보려고 작은 사이드프로젝트를 했었는데 이제 막 프로그래밍을 부트캠프를 마친 사람 모였었어요.. 3주간 아무것도 못하고 강의만 듣는것같길래 뭐라도 작성해봐야하지 않겠나 라고 얘기했었는데.. 그것도 침묵의 시간이 아닐까 라고 생각하게 되더군요.제가 생각했을때 침묵의 시간은\n수학으로 치자면 정의를 이해하고 받아들이기, 정의와 예제 연결하기, 정의로부터 정리 연결하기 등의 사고활동들이 떠오르는데, 이런 내재적 연결성이 잘 형성되지 않은 모호한 시간을 말하는것같더라구요. 새로운 기술의 새로운 api를 보고 내부로직은 전혀 모르지만 몇가지 기능이 작동하는것만보고 내부로직을 추론하는 단계의 경우가 비슷한 케이스가 아닐까.. 정신모델이나 개념에 대한 스키마 형성이 잘 되어있지 않은듯 하다.. 라고 생각이 드네요.내부로직이 항상 드러난 수학과 달리 내부로직이 블랙박스처럼 가려진 학습대상들을 잘 이해하기 위해선 다양한 사용사례를 보고 블랙박스 내부를 채워가는 신경망학습과정이 필요한것같고 그 채움의 시간을 침묵의 시간으로 부르는것같다고 생각했습니다.이렇게 첫번째 인지 단계가 잘 해결된다면, 개념에 대한 스키마가 잘형성되고 정신모델이 확립된다면, 비로소 연결가능한 개념들을 더 상세히 인지할 수 있고 잘 연결시킬 수 있는 도구적 사고의 단계, 이해 이후의 적용과 응용 가정 추론 구조화 재구조화 변형 재정의 등 복잡한 단계로 넘어가게된다고 생각해용. 영상에서 말한 유일한방법이라는 강조는 아마 이런 형식적 사고의 단계이전에 정의적이해단계에서 관여하는것들에 한정된것같습니다."}},"/marblewriter_magazin":{"title":"구슬글방 매거진","data":{"":"세컨드브레인 커뮤니티 구슬글방 핵심멤버의 기고문은 여기에서 보실 수 있습니다.월간 구슬글방 매거진"}},"/marblewriter_magazin/expressions":{"title":"'비폭력 대화'와 말. 그럼 표정은?","data":{"":"","몸과-얼굴#몸과 얼굴":"우리는 대게 몸에 대해 기능적 해석을 갖고 있다. 예를들면 눈은 시각정보를 인지하기 위한 인지기관. 손은 무언가를 수행하기 위한 도구적 기관, 다리는 신체의 위치를 변경시키기 위한 기능기관 등으로 말이다.이런 해석에는 대체적으로 전제조건이 깔려있는데, 자신에게 어떤 기능을 수행하는지에 대한 것이다. 그런데 자신에게 어떤 기능을 수행하는가 보다 다른 사람에게 나 자신의 어떤 정보를 전달하기 위한 핵심 기관이 있다면, 그것은 얼굴이라고 볼 수 있다.얼굴은 거의 다른사람에게 보여지기 위해 기능하는 편이다. 특히 시선과 표정 말이 그렇다. 이번에 다룰 이야기는 말과 표정이다.","말과-표정#말과 표정":"다른 사람의 말을 듣고 영향을 받는 일은 종종 발생한다. 특히 다른 사람이 내가 관심있는 대상에 대해 말할 때 더욱 그렇다. 그런데 관심의 대상이 어떤 사람이라면, 우리는 말보다 표정을 더 중요하게 여기고는 한다.말은 소위 말하는 주체 화자의 의지와 사고가 반영되어있다. 그러나, 표정은 사고가 작동하기 이전에 이미 작동되어진다. 표정은 감정의 동요에 따라 즉각적으로 드러난다. 물론 표정도 사람의 성격에 따라 필터링 되어지는 정도의 여부는 각각 다르지만, 근본적으로 감정과 동기화되어있다는 점이 말과 다른점이다.그래서 우리는 말로부터 타인이 생각하는 방향에 대한 정보를 읽을 수 있는 반면, 표정으로부터 그들이 무엇을 느끼는지에 대한 정보를 얻어낼 수 있다.","표정의-발생과-표현#표정의 발생과 표현":"감정은 정보를 인지하는 가치기반 인지체계의 트리거로부터 신체적 반응이 유발되고, 책 회복탄력성의 저자이신 김주환 교수님이 말씀하셨듯이 반응적 신체 상태에 따라 뇌의 편도체를 중심으로 특정기억들이 연결 연상되며 우리 전두엽의 활성화와 상관없이 반응적으로 표정에 나타난다.즉 우리는 상대방의 표정을 통해 어떤 대상을 어떻게 느끼는지 추론할 수 있고, 네이처지에 발표된 연구에 따르면 표정을 16개로 분류할 수 있고 그것은 즐거움, 분노, 경이로움, 집중, 혼란스러움, 경멸, 만족, 욕망, 실망, 의심, 의기양양함, 흥미, 고통, 슬픔, 놀라움, 승리 등이라고 한다. 이 모든 감정을 다시 크게 묶는다면 긍정감정과 부정감정으로 나눌 수 있을것이다. 우리는 상대방의 표정을 통해 어떤 해석 대상이 긍정적인지 부정적으로 느끼는지 추론할 수 있으며 그로인해 상대방이 가진 가치체계 혹은 신념체계까지 깊게 대략적으로 추측 해낼 수 있다.반대로 우리는 자신이 느끼는 정서를 타인을 향해 표정으로 드러낸다. 이는 인식하는 대상에 대해 부정적으로 느끼는지 혹은 긍정적으로 느끼는지에 대한 정보를 적나라하게 제공해줌으로서, 나 자신이 부정적으로 느끼는 대상 혹은 존재가 무엇인지 알리고, 긍정 부정 사이의 가이드라인을 상대방에게 제공하는것과 같다.이 가이드라인, 즉 선을 잘 인지하는 사람들은 소위 눈치가 빠르다고 여겨진다.눈치가 빠른 사람들은 타인을 잘 관찰 할 줄 아는 사람들이다. 그들은 사람이 나타내는 표정을 통해 어떤 정보에 대해 집중하는지 더 깊게는 해당 정보에 대해 긍정적으로 혹은 부정적으로 생각하는지 추론한다.긍정적이라면 해당 대상을 더 공급해주고, 부정적이라면 대상의 공급을 제한하거나 필터링하는 방식을 거치는 것이다. 어느 누가 나를 위해 이런 대처를 해주는데 싫어할 사람이 있을까.하지만 사람이 어찌 타인을 긍정할수만 있을까. 분명 어딘가에 부정할만한 것들이 있을 수 있다.만약 타인이 느끼는 부정적 대상으로 나이거나 나의 일부 혹은 내 의지가 반영된 무엇일때 우리는 어떻게 느낄까?","표현과-관계#표현과 관계":"인간관계에 있어서 때때로 말보다 표정이 더 중요하게 작용할때가 있다.우리는 말할 수 없는것에 대해서 종종 말하곤 하지만, 대체로 표정 지을 수 없는것에 대해서는 표현하지 않는다. 그도 그럴것이 표정은 애초에 잘 통제되지 않는다. 표정은 대상의 인지와 동시에 즉각적으로 반응되어지는것으로, 사고보다 느끼는것에 가까워 느끼는것을 즉각적으로 통제할 수 없는것과 마찬가지다. 우리는 자신이 어떤 표정을 짓고 있는지 모르는 경우도 상당하다.반면 말은 표정에 비해 훨씬 풍부하게 발화자의 인지영역으로 들어온다. 본인이 무슨말을 하는지 (감정을 주체하지 못해 말을 쏟아내는게 아니라면) 명확하게 인지하고 그 말이 뭘 의미하는지 의도까지 전달하기 위해 노력한다. 말을 하는 도중 우리는 종종 상대방의 반응을 살피고 반응에 따라 말을 어떻게 조절할지 결정하기도 한다. 말에 대해 우리는 아주 적극적으로 개입하게 된다.아까 표정이 나타내는 가이드라인을 떠올려보자. 긍정적인 반응의 대상들을 한되 모아 가이드라인을 작성하고 내부를 긍정성의 원이라고 하자.긍정성의 내부에 속하는 모든 존재들을 뭉뚱그려 일컬어 ‘나’의 세계라고 할 수 있지않을까. 긍정의 외부에는 부정의 대상들과 무관심의 대상들로 나눌 수 있고, 이들 사이에는 타인의 긍정성과 부정성이 있을 수 있다.이때 나의 세계에 속하지 않는 부정성들은 나에게 영향력이 없다. 나조차도 부정하거나 무관심하기 때문이다. 하지만 만약 내가 긍정하는 세계에 속하는 대상을 누군가 부정한다면 어떨까? 심지어는 내가 긍정하는 타자가 내가 긍정하는것을 부정할 때 어떨까? 이때부터 우리는 혼란스러운 상황에 빠지게 된다.내가 긍정하더라도 너는 부정할 수 있지. 라며 유연하게 대처하는 사람들도 있고, 보다 맹렬하게 그걸 부정해선 안돼 라며 반응할 수 도 있다.하지만 그 어떤 사람이라도 부정의 대상이 나 자신이거나 나의 일부라면 내면의 갈등에 빠지게 될 수밖에 없다. 논리적으로 모순이 나타나기 때문인데, 내가 긍정한 대상이 나를 부정하는 사건을 마주할 때, 마치 짝사랑의 고달픔처럼 타인을 긍정하고 자신을 부정하게 될 수 있지 않을까. 만약 타자도 긍정하고 나 자신도 긍정하려면 긍정과 부정 사이의 골을 소통으로 채워내야만 할것이다.이런 부정성에 특히나 말보다 표정이 앞선 부정성이었다면, 이 표정의 근원이 가치관의 문제 세계관의 문제에서 비롯된 가치판단의 정서라면, 시간과 공을 들여 소통을 통해 개선하기 쉽지 않을것이다. 해당하는 부정성이 뿌리깊은 느낌의 영역, 서로 병합되지 않는 가치관의 영역에 있다면 조절도 힘들뿐만 아니라, 각자가 살아온 세월만큼이나 변하기 어렵고, 우리는 종종 관계 자체를 재정의 하고는 한다.말의 공격성은 폭력적일 수 있지만 표정의 공격성은 파괴적 일 수 있는게 아닐까.비폭력 대화는 느낌의 뿌리깊은 영역에서 나타난 균열을 매워 낼 수 있을까?","chatgpt#chatgpt":"말은 조절가능한것같은데 표정은 조절하기가 힘든것같아. 왜그런걸까??\n\n말과 표정의 조절능력 차이는 말과 표정이 서로 다른 뇌 회로를 사용하고, 생물학적 유산과 사회적 경험의 영향을 받기 때문입니다.\n\n1. 다른 뇌 회로의 사용: 말은 주로 언어 및 운동 기능 관련 지역(예: 브로카 영역)을 사용합니다. 이 과정에서 발화, 단어 선택, 문법 등의 조절이 가능합니다. 반면, 표정은 애초에 감정의 자연스러운 반영으로 시작되며, 무의식적으로 생성되기도 합니다. 여러 뇌 영역 중 안면 운동 피질이 안면 근육의 움직임에 관여하지만, 이들의 조절은 의도적이지 않은 경우 힘들 수 있습니다.\n\n2. 생물학적 유산: 말은 사회적 소통 도구로 자연 선택 과정에서 인간의 고유한 능력으로 발전했습니다. 따라서 말의 의도적인 조절이 인간의 기본 능력 중 하나입니다. 반면, 표정은 진화 과정에서 다양한 종에서 발견되며, 자동적이고 감정의 직접적인 반응입니다.\n\n3. 사회적 경험: 사회적 교육과 경험을 통해 언어 습득 및 의사소통 방법에 깊이 관여합니다. 반면에 표정은 어려운 상황에서 본능적으로 반응할 수 있는 능력을 향상시키는 데 더 집중되어 있는 태생적 기능입니다.\n\n\n그러나 표정을 조절하기 어렵다고 해도, 이를 일부 조절하는 능력이 없는 것은 아닙니다. 어떤 사람들은 전문적인 연기 훈련이나 일상 경험을 통해 표정을 의도적으로 제어하는 법을 배울 수 있습니다. 또한 적절한 시기와 상황에 맞게 표정을 조절하는 것은 사회적 기술의 중요한 부분이기도 합니다. 하지만 전반적으로 표정 조절은 말의 조절보다 어렵다고 할 수 있습니다.\n\n정보를 인지하고 표정이 나타나기까지의 작동원리에 대해서 순차적으로 설명해줄래?\n\n사람이 정보를 인지하고 표정이 나타나기까지의 작동 원리를 순차적으로 살펴보겠습니다:\n\n1. 감각 입력: 눈, 귀, 코, 입, 피부와 같은 감각기관에서 외부 환경의 정보가 수집됩니다. 이 정보는 무언가를 보거나, 듣거나, 맛보거나, 만지거나, 냄새 맡는 등 다양한 방식으로 입수될 수 있습니다.\n\n2. 정보 처리: 감각기관을 통해 입력된 정보는 중추신경계로 전달되어 처리됩니다. 이 과정에서 적절한 뇌 영역에 정보가 전달되고, 두뇌가 이 정보를 해석하여 인지되는 정보로 변환됩니다.\n\n3. 감정 생성: 정보 처리 과정에서 얻어진 인지된 정보는 개인의 경험과 상황에 따라 연관된 감정과 연결될수 있습니다. 표정에 반영되는 감정은 발생하기도 하며 이미 존재하는 감정 변화에 영향을 줄수 있습니다.\n\n4. 전두엽에서의 감정 조절: 뇌에서 감정이 생성되면 전두엽-특히 벤트랄메디알 프리프론탈 코텍스(ventromedial prefrontal cortex) 등의 영역이 감정과 관련된 반응을 조절하는 역할을 담당합니다.\n\n5. 안면 근육 활성화: 감정 조절 과정에서 뇌는 감정에 상응하는 표정을 만들기 위해 안면 근육을 활성화합니다. 이 과정에서 안면 운동 피질(facial motor cortex) 영역이 뇌에서 발신되는 신호를 안면 근육에 전달합니다.\n\n6. 표정 생성: 활성화된 안면 근육은 특정 패턴으로 움직입니다. 이러한 움직임이 조화를 이루면 감정을 나타내는 표정이 생성됩니다.\n\n\n이러한 과정을 통해 주변 환경에서 정보가 인지되어 처리되고, 감정이 발생하고 조절되며, 마침내 표정이 생성됩니다. 표정은 감정을 표현하는 동시에 다른 사람들과 소통하는 매우 중요한 방법입니다. 여러 상황에서 다양한 원리의 실행과 조절은 개인의 경험, 성격, 문화적 배경 등에 따라 결과가 달라질 수 있습니다.\n\n그럼 이번엔 정보를 인지하고 말을 하기까지의 작동원리에 대해 순차적으로 설명해줘\n\n사람이 정보를 인지하고 말을 하기까지의 작동 원리를 순차적으로 살펴보겠습니다:\n\n1. 감각 입력: 눈, 귀, 코, 입, 피부와 같은 감각기관에서 외부 환경의 정보가 수집됩니다. 이 정보는 무언가를 보거나, 듣거나, 맛보거나, 만지거나, 냄새 맡는 등 다양한 방식으로 입수될 수 있습니다.\n\n2. 정보 처리: 감각기관을 통해 입력된 정보는 중추신경계로 전달되어 처리됩니다. 이 과정에서 적절한 뇌 영역에 정보가 전달되고, 인지된 정보로 변환됩니다.\n\n3. 언어 생성: 인지된 정보를 바탕으로 주어진 상황과 맥락에 따른 말의 내용이 생성됩니다. 이 과정에서 워니케 영역(Wernicke's area)이 어휘와 문법을 통한 언어의 의미 생성을 돕습니다.\n\n4. 말하기 계획: 브로카 영역(Broca's area)가 언어를 구성하는 방식을 계획합니다. 이 영역은 말의 구조를 결정하고, 문장 구조와 발화를 조절하는 데 관여합니다.\n\n5. 운동 피질 활성화: 브로카 영역에서 생성된 말의 정보가 신호로 변환되어 기본 운동 피질(primary motor cortex)로 전달됩니다. 이 영역은 말을 하기 위해 구강 근육(입, 입술, 혀, 상악)을 움직이는 데 필요한 운동 신호를 생성합니다.\n\n6. 발화: 생성된 운동 신호들은 구강 근육에 전달되어 음성기관(폐, 성대, 인두, 구강, 코강)이 음을 생성하고, 말 소리가 완성됩니다.\n\n\n이러한 과정을 통해 사람은 정보를 인지하고 처리한 후, 언어 생성 및 발화를 통해 말을 할 수 있습니다. 상황, 개인 경험, 성격, 문화적 배경 등에 따라 이러한 과정에도 변화가 있을 수 있습니다."}},"/marblewriter_magazin/predictable_target":{"title":"예측가능한 목표","data":{"":"목표중심 동기이론이 제법 많이 알려져있다.\n하지만 가장 중요한게 빠져있다. 예측가능성.\n목표는 그냥 설정한다고 동기가 되는게 아니라 예측가능한 목표여야 이미 시뮬레이션 된 동작들을 행동으로 자동적으로 수행가능하게 되는것이다.예측가능하지 않은 목표는 목표가 아닌게 아닐까"}},"/marblewriter_magazin/search_path_for_concept_map":{"title":"영감과 대화, 경로탐색","data":{"":"","영감의-개념#영감의 개념":"우리는 각자가 학습한 대로의 개념을 갖고 있다. 여기서 개념이란 실제적이거나 추상적 관념의 한 단위로, 그 자체로 추상적이나, 어떤 다른 개념, 관념, 경험 연결될 때, 그 쓰임새를 보여주게 된다. 즉, 개념은 독립적이고 단독적으로 존재한다기보다 무언가와 연결되는 분기점의 역할을 하기도 한다.영감이란 개념 자체도 사용되는 맥락에 따라 해석이 달리 되게 마련이다. 영감이란 표현은 대게 종교나 예술에서 많이 사용되는데, 종교에서는 신이 내려준 지혜나 생각을 뜻하고, 예술에서는 창조적인 일의 계기가 되는 빼어난 착상이나 자극을 말한다. 그리고 우리는 대화하면서 영감을 얻는다는 표현을 종종 하게 된다.영감은 학습된 개념이 가진 연결경로 이외의 새로운 경로(한 개념의 새로운 시각 혹은 사용 방법)를 발견하게 되는 순간이거나, 혹은 기존의 연결경로를 수정하는 경우, 혹은 개념 자체의 정의를 수정하는 경우 등을 예로 들 수 있다. 이러한 변화를 총체적으로 다시 보면 영감은 결국, 인지된 개념이 변화되는 과정과 매우 연관이 깊다는 것을 알 수 있다. 개념변화의 과정은 학습 과정 그 자체를 의미한다.즉 영감은 학습의 본질 위에서 작동한다는 것을 알 수 있다.영감이 대화하면서 많이 발생하는 이유도 교수학습의 원리와 같다. 타인의 말을 집중해서 듣는 행위, 몰입해서 이해하는 과정을 통해, 타인이 사용하는 개념이 어떤 상황 어떤 맥락에서 무엇과 어떻게 연결 적용되는지를 이해하는 과정에서 내가 이전에 미처 학습하지 못한 사용성이나 시각을 깨닫고 이해하게 되고, 이를 통해 영감을 얻어 새로운 활동이 유발된다. 이 새로운 활동을 통해 기존의 개념에 새로운 시각과 연결되기도 하며, 기존의 연결 과정을 뒤엎어 내기도 한다. 이 과정 교육의 본질과 맞닿아 있다. 그래서, 교육의 상당 부분은 대화로 구성돼 왔다.학습의 관점에서 책이 더 많은 영감을 줄 수 있겠지만, 대부분 사람은 대화하면서 영감을 얻는다고 한다. 이유는 간단하다, 책은 나를 이해하고 피드백을 줄 수 없지만, 사람은 어느 정도 가능하기 때문이다. 그래서 책이 더 위대한 영감을 줄 수 있을지언정 독자를 고려해서 정보를 제공하지 않기 때문에 우리는 많은 영감을 대화에서 얻어낸다.그럼, 대화와도 같이 사람들에게 영감을 제공할 수 있는 수단은 없을까? 책처럼 모든 걸 다 읽어야만 이게 똥인지 된장인지 구별할 수 있지 않고, 사람처럼 나에게 필요한 영감을, 개념적 학습 가능 지점을 찾아낼 방법은 없을까?","택시와-네비게이션#택시와 네비게이션":"내비게이션이 없던 시절에는 택시 기사의 지식은 그 자체로 엄청난 가치가 있었다. 지금에야 택시의 지식보다 내비게이션을 더 믿는 시대가 되었지만, 내비게이션이 없던 시절, 지도과 위치에 관한 지식은 사회적으로 늘 높은 가치를 인정받아 왔다.더 이전의 시대로 거슬러 올라간다면, 지도가 없던 시대와 지도가 있는 시대로 나눠 생각해 볼 수 있는데, 지도가 없던 시대에는 유경험자의 지리적 정보의 가치가 매우 높은 평가를 받았다.\n상인들은 늘 사람들과 대화하며 어디에 어떤 물건이 있는지 어디에 어떤 물건이 필요한지 경험하여 학습하고 그 정보가 정확할수록 더 큰 부를 얻을 수 있게 되었다.\n그뿐만 아니라, 지리적 정보는 군사전략의 가장 핵심이 되는 정보다. 전쟁에 앞서 고지대를 미리 선점해 낸다면, 강한 이점을 가질 수밖에 없는 게, 각종 투사체의 사거리가 길어질 뿐만 아니라 전투 시 체력적으로도 우위를 점할 수 있었다.현대에 이르러 이런 지리적 정보를 데이터베이스에 넣고, 원하는 위치에 도달하는 최단 경로를 산출해 주거나, 최소시간경로를 추천받을 수 있게 되었다.하지만, 우리 교육은 아직도 전통 방식 그대로를 벗어나지 못하고 있다.교육은 개념이 변화되어 가는 과정이고, 개념은 연결가능한 경로의 한 분기점으로 추상화시킬 수 있다면, 개념에 대한 지도도 충분히 만들어 낼 수 있을 뿐만 아니라, 내비게이션도 만들어 낼 수 있다.비약이 있는데 비약을 채워보자. 개념이 왜 분기점이란 말일까?","개념과-문제해결#개념과 문제해결":"앞서 언급했듯 개념과 문제해결은 미로에서 길 찾기와 굉장히 연관이 깊다. 애초에 개념을 사고하는 뇌의 뉴런 연결구조 자체가 아주 복잡한 미로처럼 구성돼 있기 때문이다.우리가 무언가에 대해 생각하게 되면 생각의 경로를 따라가다 개념적 분기점에 이르게 되고, 분기점에서 한 경로를 선택하여 개념의 이어서 생각하곤 하는데 이 과정은 뉴런이 정보를 처리하는 과정과 일치한다. 뉴런은 자극받은 전기적 신호를 연결된 뉴런 중 특정 경로에 선택적으로 전기적 신호를 보낼 수 있고, 이때 활성화된 경로의 뉴런이 해당 경로와 연결된 회로를 가동하면서 집중의 요소를 한 방향으로 제한시킨다.우리 뇌는 무엇에 대해 생각하면서 끊임없이 분기점 사이에서 길 찾기를 하는 것과 같다. 그리고 문제해결을 잘 해내려면 개념이 가진 연결경로가 모두 학습되어 있을수록 유리하다.하나의 문제상황은 문제해결에 앞서 여러 가지 해답이 있을 수 있지만 아무 데나 가도 늘 문제를 맞힐수 있는 것은 아니다. 특정 방법들 안에서만 문제가 해결되는 경로가 존재하고, 그 경로의 분기점에는 이 개념을 어떻게 활용해야 할지, 어떤 방식으로 바라봐야 할지, 어떻게 활용해야 할지, 개념 사용의 경로를 선택해야만 한다.그래서 문제해결의 가장 중요한 점은 개념이 가진 경로의 전체적 특성을 얼마나 잘 이해하고 있는가, 이 시도가 먹히지 않는다면 어떤 시도를 할 수 있을 것인가? 라는 물음들의 연속과도 같다. 만약 개념학습이 잘 되어있지 않다면, 개념 연결성에 제한이 생기고 이 제한이 생긴 경로를 사용해야만 풀리는 문제에서 늘 막다른 골목에서 서성이게 될 수밖에 없는 것이다.이를 해결하기 위해 선인들은 그리고 성공한 사람들은 늘 책을 보라고 말하지만, 지식의 적합성이 늘 잘 맞는 것은 아니고 그러다 보니 당장 필요한 몇 가지 개념을 얻어내기 위해 해당 분야의 전문서적 10권 이상의 책을 학습해야만 한다.마치 내비게이션이 없던 시절에 전혀 모르는 곳에 도달하려고, 이 사람 저 사람 물어물어 열 사람 이상의 전문가에게 물어 정보를 취합해서 모험을 떠나는 것과 같다. 이게 작금 교육의 형태다. 전문가에게 물을 수 있으면 다행이나, 거의 무한대로 쏟아져 나오고 있는 수많은 강의들 사이를 여전히 떠돌아야만 한다.컨텐츠가 엔트로피의 법칙을 순리대로 따르며 무한히 증식하고 있는데, 우리 똑똑한 내비게이션은 증식하지 않는다. 그 비결은 정확한 데이터와 정확한 연산 처리에 있다. 미로 문제 풀이 알고리즘에 솔루션에 대한 힌트가 들어있는데, 핵심은 하이라키구조가 가지고 있다.","미로와-트리구조-경로탐색#미로와 트리구조 경로탐색":"위와 같은 미로가 있다고 해보자. 전체 그림을 보면 풀기 어렵지 않겠지만, 미로 안에 갇혀서 전체모습을 볼 수 없다면, 미로가 더욱 복잡해진다면 출구를 찾기 쉽지 않을 수 있다.문제해결에는 정해진 경로를 걸어나가는 능력과 분기점에서 선택할 수 있는 모든 경로를 인지하는 능력, 그리고 잘못된 경로로 들어섰을 때, 이전에 선택했던 경로가 무엇이었는지 기억하는 능력이 필요하다.이때 경로선택의 분기점을 개념이 필요한 상황이라고 볼 수 있었는데, 그림으로 표시하면 다음과 같다.\n\n빨간 블럭에서 파란 블럭으로 나아가고자 할 때 분기점을 모두 표시하면 그림의 녹색 블럭과 같다. 각 분기점은 경로를 선택해야 하며, 이때 분기점이 개념을 마주했을 때, 이 개념을 어떤 방식으로 연결시킬지 선택하는 과정이라고 볼 수 있다.만약 개념에 대한 학습이 덜 되어있어서 1번 분기점에서 아래로 가는 경로가 학습되어 있지 않다면 이 미로에서의 문제해결은 시작부터 어려움에 봉착하게 되는 것이다.\n\n\n뿐만 아니라 보통 문제상황은 중간 과정이 좀처럼 보이지 않는 경우가 많다.\n\n\n하지만 수많은 개념은 이미 대중에게 열려있고 정보의 바다 위에 떠돌아다니고 있다. 문제는 그 개념들이 잘 구조화되어 있지 않다는 것이다.인터넷에는 수많은 정보가 있지만 상당수가 구조화된 정보가 아니다 보니, 방대하게 복제되고 무분별하게 쏟아져나오고 있다. 현재 언어 학습 인공지능은 이런 문서들을 사람이 정제해서 가공된 데이터를 학습시키고 있지만 여전히 계층화된 정보는 아니라는 점에서 한계점이 있다.위의 미로처럼 명료하게 계층화시킬 수 있다면 보다 똑똑한 인공지능이 나오는 것은 자명하다.\n\n\n이 그림의 미로가 왜 계층화되어 있다는 걸까?\n각 분기점에서 이어지는 경로를 표시하면 위 그림과 같은데 이를 하이라키로 변환하면 다음과 같다.\n\n\n이런 문제상황에 있어서, '길을 찾는다', '방법을 찾는다', '영감을 얻는다'는 말은 위 계층구조의 각 분기점에서 어떤 방향으로 나아갈지 학습한다는 개념임과 동시에 새로운 시각을 얻는다는 말과 동일하다. 기존에 학습되지 않았던 지식에 새로운 문제해결의 출구가 열린다면 동기가 되지 않을 수 없다.컴퓨터 알고리즘은 이런 경로 탐색에 아주 효율적인 연산이 가능하다. 물론 모든 경로가 학습되어 있다는 전제조건 하에서 가능하다. 특히 하이라키 구조는 지식이 방대해져도 그 양이 점차 수렴되어 가는 양질의 정보 계층이기 때문에 연결성의 논리적 힘이 아주 강력하다고 볼 수 있다. 수학 문제를 해결할 때도 이 하이라키 경로 탐색과 정은 우리 머리속에서 그대로 나타나게 된다. 사실상 이 탐색 알고리즘 자체가 인간의 사고를 모방해서 만들었기 때문이다.위 문제는 중3 수학인데, 고등수학의 등비수열을 이용해서 문제를 풀어도 되지만 중2 기하학의 비례식을 이용해서 문제를 풀 수 있는데 풀이 과정은 다음과 같다.주어진 식으로부터  ,  로부터 다음 항이 될 때 1/3배씩 곱해진다는 패턴을 찾아내고,닮은 도형의 넓이의 비는 길이에 비의 제곱과 같다는 닮음 개념의 한 경로를 떠올려 닮음비를 찾아내고 과 정삼각형의 넓이 으로부터 한 변의 길이를 구하는 방정식 개념을 떠올려나온 결과물들을 연립방정식으로 연산하면 정답을 구할 수 있다.풀이에서와 같이 수학에서 문제해결은 각 개념의 활용을 선택하는 사전지식에 의해 문제해결에 대한 경로를 찾아내는 것과 같다. 또 수학은 엄밀하게 정돈된 하이라키 구조로 되어 있기 때문에 하나의 개념에 대해 모든 경로를 탐색했다면 더 이상 해당 영역에 대해 고민할 여지 자체가 없어지는 것이다.로지컬 싱킹, 박문호 박사님의 집합론적 사고, 직장인들이 배우는 MECE한 사고방식까지 모두 이 트리 구조적 사고방식을 논리의 베이스에 가져가고 있다.하지만 세상엔 트리 구조로 표현되지 않는 정보가 무수히 많다. 그럴 땐 어떻게 할까?","비선형-비-계층-구조-그래프-구조에서의-경로-탐색#비선형 비 계층 구조, 그래프 구조에서의 경로 탐색":"미로를 조금 더 변형시키면 아래와 같은 상황이 더 복잡하게 연결될 수 있게 되기도 한다.\n\n이 미로의 경우 계층구조로 회귀하지 않는 그래프구조를 띄고 있는데, 1번 분기점과 8번 분기점이 연결됨으로서 위 1번과 8번 중 어느 분기점이 상위구조인지 명확하지 않은 경우가 발생한다. 어떤 문제를 풀다 보니 다시 처음 상황으로 되돌아오는 경우를 말한다. 이런 아일랜드형 경로가 두세 개만 얽혀있더라도 자칫 잘못하면 길을 잃어버리기 십상이다. 이런 상황에서는 문제를 해결해 나가려면 목적지의 방향으로 경로를 우선 선택하되 지나간 경로는 길목에 표시해서 찾아나가야만 한다. 헨젤과 그레텔이 집에 돌아가기 위해 마크해 둔 것처럼.이런 상황은 컴퓨터가 더욱 전적으로 유리할 수밖에 없는데, 단시간에 모든 경로를 계산해서 최단 거리를 찾아낼 수 있기 때문이다. 심지어는 모든 경로를 탐색하지 않고도 최단 경로를 찾아내어 내비게이션처럼 길을 제공할 수 있다. 우리가 흔히 게임에서 목적지를 클릭하면 자동으로 경로 검색하는 알고리즘이 거의 실시간으로 연산 되어 즉각적으로 반응하는 모습을 볼 수 있기도 하다.하이라키가 논리적인 힘을 만들어 준다면, 하이라키가 아닌 비선형구조의 경로 탐색 기능은, 시각정보(내비게이션)를 제공하고 효율성(최단 거리)을 제공한다.학습에서 이런 서비스는 전문 선생님의 과외 말고는 방법이 없다. 즉 과외선생님이 해주는 교육 서비스는 지식에서의 경로 탐색 알고리즘에 가깝다는 말이다.","차세대-인공지능-교육-서비스#차세대 인공지능 교육 서비스":"현재 인공지능은 문자 단위로 구축되어 서비스되고 있다. 인터넷에 있는 글자들의 연관정보를 입력시켜 학습해 그래프 구조에서 나름의 내비게이션 역할을 문자 단위에서 해주는 서비스이다. 하지만, 문자 단위가 아니라 사고의 기본단위는 개념이기 때문에 개념의 연결이 카테고리 없이 연결되어 학습된 수준에서 언어모델이 아니라, 개념과 개념들이 어떻게 연결되어 있는지 충분히 잘 모델링된 데이터를 토대로, 생각의 경로를 온전히 제공해 주는 서비스가 나올 수 있을 것으로 기대한다.그렇게 하기 위해서는 보다 진보된 집단지성이 구축되어 있어야 하며, 현재의 위키백과를 뛰어넘는 더 양질의 집단지성의 장이 필요하다. 그리고 그 장에서는 하이라키와 그래프 연결이 구분되어 있어야 한다. 논리의 장 하이라키영역에서는 지식들이 끊임없이 수렴되어 최첨단의 지식과 연결되어 있으면서 동시에 생성의 장 그래프영역에서는 개인의 사소한 생각도 연결되며 확산되어야한다. 그러한 엄밀하면서 또 어설프거나 신선한 연결들의 총체는 우리를 더 나은 교육혁신의 현장으로 이끌 것이다. 굳이 인공지능이 아니라, 그냥 경로 탐색 알고리즘만으로도 말이다."}},"/obsidian/*obsidian":{"title":"궁극의 오프라인 마크다운 에디터","data":{"":"옵시디언은 너무 많은 플러그인 탓에 진입장벽이 존재하지만 그만큼 수많은 기능들을 내포하고 있는 사랑받는 마크다운 에디터이다. 웬만한 유료 에디터의 모든 기능들을 무료로 쓸 수 있음에도 불구하고 체계적으로 문서를 관리할 수 있다.","플러그인#플러그인":"plugin_terminal : 옵시디언을 깃과 연동하기 위해 깃 플러그인을 사용해도 되지만 터미널을 쓴다면 더 안전하게 사용할 수 있지 않을까."}},"/obsidian/plugin_terminal":{"title":"터미널 플러그인","data":{"":"옵시디언 커뮤니티 플러그인에 찾아보면 유일한 터미널 플러그인이 하나 있다."}},"/programming/elixir/정보들":{"title":"정보들","data":{"":"https://seokjun.kim/elixir-phoenix-liveview-svelte-how/엘릭서 피닉스 라이브뷰 스벨트 튜토리얼"}},"/programming":{"title":"Rust","data":{"":""}},"/programming/mac/*mac":{"title":"*mac","data":{"":"한영전환 shift + space 로 변환하기\nyabai 개발자의 맥북 윈도우 매니저\nzsh, ohmyzsh 터미널을 이쁘게 편하게"}},"/programming/mac/hangul":{"title":"맥에서 한영키 전환 shift + space 로 변경하기","data":{"":"맥에서 한영키를 이런 저런 바인딩해서 사용하는 경우가 있는데,\ncapslock키로 바인드하는 경우 입력시간이 조금 길어지면 한영키 전환이 아닌\n대문자모드로 변경되는 경우가 있어 입력오타가 자주 발생한다.\n그렇다고 기본 변환인 ctrl + space 를 사용하자니 맥북 키보드에선\nfn 키 앞에숨어있어서 불편하고 외장키보드를 사용한다 해도 새끼손가락을\n제법 아래까지 내려야한다는 점에서 또 불편하다.구름 입력기를 사용하면 shift + space 키로 변경가능한 옵션을 제공하는데,\n모든곳에서 전혀 문제가 없지만 빔에서 사용시 띄어쓰기가 입력된다는점이다.다행히 맥에서는 핫키를 관리하는 파일이 있다. 해당 파일을 열어보자.","핫키파일#핫키파일":"그림처럼 파일이 깨져서 나오는데, 파일이 바이너리로 컴파일 되어있기 때문이다.\n이 파일은 xml 파일로 구성되어져 있으니 컨버팅이 필요하다.","컨버팅#컨버팅":"plutil -convert xml1 ~/Library/Preferences/com.apple.symbolichotkeys.plist","키설정-변경#키설정 변경":"파일이 잘 보이고 이제 문제의 한영키 셋팅에 가서 수정하면 된다.\n그림과 같이 61번 키의 내부 배열에서 마지막 숫자를 131072로 바꿔주자.\n저장하고 이후 다시 바이너리 파일로 컨버팅이 필요하다.","컨버팅-1#컨버팅":"plutil -convert binary1 ~/Library/Preferences/com.apple.symbolichotkeys.plist\n이제 맥을 리부트하면 한영전환이 변경된다."}},"/programming/mac/yabai":{"title":"yabai 맥 윈도우 매니저","data":{"":"맥 사용자라면 누구나 윈도우 매니저를 경험해봤을 것이다.\n맥에서도 기본적으로 제공되는 스테이지매니저가 있다.\n\n그 외에도 무료 윈도우 매니저인 Rectangle이 아주 유명한데, 특징은 모두 마우스 전용이라는 점이다.개발자들은 특성상 마우스보다 키보드가 더 가깝고 익숙해서 이런 불편함을 공감하는 제작자분이 yabai를 만들어주었다.","yabai#yabai":"야바이는 마우스 없이\n창의 포커스를 이동하거나\n창의 위치를 전환\n창의 디스플레이를 전환\n자동레이아웃\n등의 대표적인 기능을 지원한다.\n\n사용하면 다음과 같은 화면을 볼 수 있다.\n\n깔끔하다.","야바이-설정#야바이 설정":"야바이 설정은 ~/.config/yabai/yabairc 파일에 보관한다.\n# bap stack or float\nyabai -m config layout bsp\n\nyabai -m config window_placement second_child\n\n# padding\nyabai -m config top_padding 12\nyabai -m config bottom_padding 12\nyabai -m config left_padding 12\nyabai -m config right_padding 12\nyabai -m config window_gap 12\n\n# mouse settings\nyabai -m config mouse_follows_focus on\nyabai -m config mouse_modifier alt\n\n# set focus follows mouse mode (default: off, options: off, autoraise, autofocus)\nyabai -m config focus_follows_mouse autoraise\n\n# left click drag move\nyabai -m config mouse_action1 move\n\n# right click drag resize\nyabai -m config mouse_action2 resize\n\nyabai -m mouse_drop_action swap\n\n# example: show shadows only for floating windows\nyabai -m config window_shadow float\n\n# Disable specific apps\nyabai -m rule --add app=\"^System Settings$\" manage=off\nyabai -m rule --add app=\"^Calculator$\" manage=off\nyabai -m rule --add app=\"^Karabiner-Elements$\" manage=off\nyabai -m rule --add app=\"^카카오톡$\" manage=off\n야바이는 기본적으로 터미널 명령어를 통해 명령이 실행되는데 이 명령을 대신 전달해줄 키맵핑 프로그림이 필요하다.","skhd-simple-hotkey-daemon-for-macos#skhd (simple hotkey daemon for macos)":"skhd를 사용하여 야바이를 조작할 수 있다.","설정#설정":"# https://github.com/josean-dev/dev-environment-files/blob/main/.config/skhd/skhdrc\n# https://github.com/koekeishiya/skhd\n\n# Changing window focus\nalt - j : yabai -m window --focus south\nalt - k : yabai -m window --focus north\nalt - h : yabai -m window --focus west\nalt - l : yabai -m window --focus east\n\n# Change focus between external displays\nalt - s : yabai -m display --focus west\nalt - g : yabai -m display --focus east\n\n# move window to display left and right\nshift + alt - s : yabai -m window --display west; yabai -m display --focus west;\nshift + alt - g : yabai -m window --display east; yabai -m display --focus east;\n\n# Rotate layout clockwise\nshift + alt - r : yabai -m space --rotate 270\n# flip along y-axis\nshift + alt - y : yabai -m space --mirror y-axis\n# flip along x-axis\nshift + alt - x : yabai -m space --mirror x-axis\n# toggle window float\nshift + alt - t : yabai -m window --toggle float --grid 9:9:1:1:7:7\n\n# maximize window\nctrl + alt - return : yabai -m window --toggle zoom-fullscreen\nctrl + alt - m : yabai -m window --toggle zoom-fullscreen\n\n# space balance reset\nctrl + alt - e : yabai -m space --balance\n\n# swap\nshift + alt - h : yabai -m window --swap west\nshift + alt - j : yabai -m window --swap south\nshift + alt - k : yabai -m window --swap north\nshift + alt - l : yabai -m window --swap east\n\n# move\nctrl + alt - h : yabai -m window --warp west\nctrl + alt - j : yabai -m window --warp south\nctrl + alt - k : yabai -m window --warp north\nctrl + alt - l : yabai -m window --warp east\nctrl + alt - left : yabai -m window --warp west\nctrl + alt - up : yabai -m window --warp north\nctrl + alt - down : yabai -m window --warp south\nctrl + alt - right : yabai -m window --warp east\n\n# move window to prev and next space\nshift + ctrl + alt - h : yabai -m window --space prev;\nshift + ctrl + alt - l : yabai -m window --space next;\nshift + ctrl + alt - left : yabai -m window --space prev;\nshift + ctrl + alt - right : yabai -m window --space next;\n\n# move window to space #\nshift + alt - 1 : yabai -m window --space 1;\nshift + alt - 2 : yabai -m window --space 2;\nshift + alt - 3 : yabai -m window --space 3;\nshift + alt - 4 : yabai -m window --space 4;\nshift + alt - 5 : yabai -m window --space 5;\nshift + alt - 6 : yabai -m window --space 6;\nshift + alt - 7 : yabai -m window --space 7;\n\n\n# stop/start/restart yabai\nctrl + alt - q : yabai --stop-service; skhd --stop-service\nctrl + alt - s : yabai --start-service; skhd --start-service;"}},"/programming/mac/zsh,_ohmyzsh":{"title":"zsh, oh my zsh","data":{"":"개발자라면 항상 터미널을 끼고 살게 된다. 터미널을 끼고 살다보면 기본 터미널이 가진 불편함을 지속적으로 느끼게 되는데, 선배개발자들도 마찬가지였는지 여러가지 터미널에서 유용한 도구들을 만들어두었다.그중 하나가 지금 소개할 zsh이다.zsh는 유닉스 계열 os에서 사용되는 텍스트 기반 쉘로 다음과 같은 기능들을 제공한다.\n강력한 텍스트 편집 기능\n강력한 셸 스크립팅 기능\n강력한 자동 완성 기능\n강력한 히스토리 기능\n강력한 배경 작업 관리 기능\n강력한 테마 기능\n\n이중에서 가장 강력한 점은 이쁜 테마를 지원하는 oh-my-zsh이다.","oh-my-zsh#oh my zsh":"오마이즈쉬를 깔아야 테마질을 할 수 있다.\n또한 zshrc(즈쉬설정파일)에 플러그인의 이름을 입력하는것으로 플러그인 설치가 가능하다.(되는 플러그인이 있고 안되는것도 있다)","powerlevel10k#powerlevel10k":"파워레벨은 터미널 테마를 내 입맛에 맞게 커스터마이징을 쉽게 할수있도록 지원해준다. 물론 이 방법을 쓰지 않고도 커스터마이징이 불가능하진 않지만, 파워레벨을 사용하면 몇가지 예제를 보여주면서 터미널에서 맘에 드는 숫자만 입력하면 해당 테마를 얻을 수 있도록 도와준다.","zap#zap":"잽은 오마이즈쉬에서 사용가능한 플러그인 매니저이다.\n잽을 사용하면 플러그인 관리가 매우 편리하다.","플러그인#플러그인":"","별칭#별칭":""}},"/programming/neovim/*lunarvim":{"title":"루나빔","data":{"":"개발자라면 누구나 vi, vim, nvim 등을 쉽게 접하고 한번쯤은 써보게 된다.vim 은 아주 오래된 텍스트 에디터로 개발자에게 사랑받아왔던 개발도구인데, 필자도 유튜브에서 빔을 이쁘게 꾸며놓고 프로그래밍을 멋지게 해내는 영상들을 보고 한번쯤 써보고 싶다는 생각을 해왔다.이후 삽질의 시간을 거쳐 루나빔에 대해 알게 되었고 지금은 커스터마이징의 수렁에서 조금은 헤어나오게 되었다.루나빔은 neovim 이후로 나온 패키징 중에서 최강자로 자리잡고 있다. 비슷한 포지션에 nvchad, astrovim등이 있으나, 많은 사람들은 루나빔을 가장 잘 구성된 패키지라고 생각하고 있다. 필자도 이것 저것 깔아서 시도해봤지만.. 빔에 대해 잘 모르는 상태에서 가장 설정없이 쓰기 좋은 도구임에는 틀림없다고 생각하게 되었다.","설치#설치":"루나 빔 설치는 공식 홈페이지를 따르면 되지만 종종 필요한 의존성이 없어서 설치 안되는 경우들이 있다. 루나빔을 설치하기 위해선 네오빔(9.0버전 이상)과 메이크(컴파일관련)가 필요하다.네오빔을 설치하는 방법은 브류(맥), apt(리눅스), scoop(윈도우) 등의 cli 소프트웨어 매니저를 이용한 방법이 있고 깃허브에서 이미지를 다운로드하거나 클론하는 방법 등등이 있는데, 리눅스에서 apt를 사용하게 되면 최신버전이 아닐 수 있으니 주의가 필요하다. 웬만하면 네오빔 깃허브를 찾아가서 설치하는게 좋다.메이크는 패키지 매니저를 통해 받도록 하자.","사용가이드내장-플러그인-포함#사용가이드(내장 플러그인 포함)":"shift+k 타입보기\n* 변수명 리팩터링\n플로팅 터미널 사용하기\n기능 단축키 검색하기","스니펫#스니펫":"컨픽루아 파일 분리적용시키기\n리액트 돔 스니펫 사용하기\n커스텀 스니펫 사용하기","추가-플러그인#추가 플러그인":"plugin-nvim-surround : 브라켓 편하게 입력 수정 삭제하기\nplugin-frog : 깃 커밋 트리 보기","설정#설정":""}},"/programming/neovim/asterisk_refactoring":{"title":"* asterisk로 변수명을 리팩터링해보자","data":{"":"","한-파일-내부의-변수명을-변경할-경우#한 파일 내부의 변수명을 변경할 경우":"루나빔에서 특정 변수의 이름을 모두 변경해야할 때가 있다.\n이때 * 키의 도움을 받으면 편하다. 노멀모드에서 커서를 특정 변수명에 위치놓고 *\n키를 누르면 자동으로 해당용어 전체를 셀렉션 해주게 된다. 일종의 매크로인 셈인데 /변수명 을 자동으로 입력해주어 검색을 도와주는 도구이다.(빔에서는 노멀모드에서 / 키를 누르고 키워드를 입력하면 현재 활성화된 문서 전체에서 해당 키워드를 검색하고 셀렉션해준다.)\n\n이제 셀렉트된 변수의 이름을 바꿔보자.노멀모드인 상태로\nciw 를 순서대로 입력하면\n커서가 단어의 중간에 있어도 단어의 시작점부터 변경하게끔 단어를 삭제하고 인서트 모드로 전환된다.\n변수의 이름을 name으로 변경하고\n인서트 모드를 종료(esc)하면\n방금 변환했던 행위가 빔의 . 매크로에 기억되어있기 때문에 반복 가능하다.\nn 키를 눌러서 셀렉션된 다음 대상으로 이동할 수 있고,\n. 키로 이전에 햇던 작업을 반복하면 변수명 변환 리팩터링이 완료된다.","여러-파일에-걸친-변수들을-리팩터링해보자#여러 파일에 걸친 변수들을 리팩터링해보자":"방법은 다르지 않다. 루나빔에서는 변수를 레퍼런스 삼는 모든 지점들을 찾아내주는 기능이 있다. 단축키는 g + r(reference)을 기본값으로 한다.\n참고\ng + d(definition)\ng + l(lsp error, warn...)\n\n\n\n변경할 이름을 찾아서 *을 먼저 눌러주고,\n해당 이름을 사용하는 레퍼런스를 검색하여 하나씩 변경하면 된다. 그러면 현재 파일에서 해당 이름을 사용하는곳을 모두 검색하면서 이 이름을 사용하는 모든 파일의 위치를 찾아준다.\n포커스가 현재 레퍼런스 창에 가있기 때문에 Enter키를 입력하면 해당 레퍼런스 위치로 이동하게 되고,\n이때 c + i + w 를 눌러 용어를 변경하면 매크로에 입력된다.\n해당파일에서 다음 변수를 찾기위해 n 키를 입력하여 다음 셀렉트 변수를 찾아내고\n. 키를 눌러 이전에 입력된 이름변경 매크로를 실행시켜준다.\nctrl + j (빔 윈도우 포커스 아래 윈도우로 이동) 키를 눌러 포커스를 레퍼런스 리스트로 옮겨주고\n작업한 파일 외부의 파일로 이동하여 이름변경을 반복해준다."}},"/programming/neovim/divide_lua":{"title":"루아파일 분리하기","data":{"":"루나빔의 설정폴더에 가면 컨픽파일만 덩그러니 있는데, 여기에 조금 설정값을 추가하다보면, 파일 크기가 점점 커져서 가독성이 떨어지게 되는 문제가 발생한다.루아파일도 가벼운 프로그래밍 언어이다보니, 모듈화시킬수 있는데, 기본적으로 require키워드를 사용한다.루아파일의 모듈 특징은 lua 폴더에 들어가 있어야 한다는 점이다.\n\n필자는 컨픽파일을 현재 이렇게 사용중이다.컨픽파일에서 별도의 루아파일을 불러올 때 lua폴더에 있는 루아파일을 불러온다는점을 주의하자.만약 루아파일 내부에 새로운 폴더를 만들고 그 내부에 루아파일을 불러올때는 몇가지 규칙이 있다\n\n위 그림과 같이 모듈을 불러오려면 다음의 규칙을 준수하면 된다.\nlua/ 아래에 존재해야한다\nlua/file.lua : require filename\nlua/folder/init.lua : require \"folder\"\nlua/folder/file.lua : require \"folder.file\"\n\n\nprint(\"custom init.lua print\")\n\nprint(\"hello by print-hello.lua\")\n입력해놓고 빔을 다시 켜면 설정파일이 로드되면서 다음과 같은 프린트가 뜬다.\n\n루아파일 가져올때 종종 오류메시지가 뜨는데, 종료후 실행해봐야 해결되는 케이스가 있다. 오류메시지 없에려고 너무 노력하지 말고, 설정이 잘 완료되면 일단 빔을 재부팅해보자."}},"/programming/neovim/floating_terminal":{"title":"플로팅 터미널 사용하기","data":{"":"루나빔에서 특별한 설정없이 터미널을 사용하는 방법은 다섯가지 정도가 있다.\n:terminal 명령어를 입력해 새탭에 터미널을 띄우\nMeta + 1 키를 입력해 하단 스플릿 터미널 띄우기\nMeta + 2 키를 입력해 우측 스플릿 터미널 띄우기\nMeta + 3 키를 입력해 플로팅 터미널 띄우\nctrl + \\ 키를 입력해 터미널 토글하기\n\n필자의 맥북에는 무슨일인지 메타키(커맨드키)가 먹히지 않아 2,3,4번 단축키 사용을 하지 못하고 있다. 남은 방법은 1번과 5번인데1번은 매우 번거로울 뿐만 아니라 탭에 있을 때 터미널에 포커싱 되어있다면 포커싱을 강제로 종료하는 방법을 못찾았다. 그래서 터미널을 매번 종료해야만 하는 번거로움이 있다.5번 선택지를 사용한다면 자동적으로 플로팅 터미널이 뜨게 된다. (버퍼에 다른 옵션의 터미널이 없을경우 기본값)"}},"/programming/neovim/flog":{"title":"Flog 깃 커밋 트리 뷰어","data":{"":"여타 IDE를 사용할때면 누가 어떤 작업을 진행했고 푸시했는지 확인시켜주는 도구들이 있다. vscode 에서는 깃렌즈라던지 훌륭한 익스텐션이 존재한다. 빔에도 마찬가지로 쓸만한 플러그인이 있다. 이번에 소개할 프로그 플러그인이다.\n\n프로그를 사용하면 위처럼 소스트리를 한눈에 볼 수 있다. 텍스트기반이다보니 여타 IDE들이 그래픽으로 보여주는 정도까지의 화려함은 없지만 개발자 특유의 멋을 낼 정도는 충분하다.설치는 간단하다.\nlvim.plugins = {\n-- git viewer\n{'rbong/vim-flog'},\n{'tpope/vim-fugitive'},\n플러그인 객체에 붙여넣고 빔을 리부팅 시키면 된다.설치가 완료됐으면 노멀모드에서 :F 키를 입력해 플러그인을 활성화 시켜보자. 실행 명령어는 세가지다.\nFlog (트리뷰어)\nFloggit (스태이터스 보기)\nFlogsplit (트리뷰어 왼쪽에 스플릿뷰로 보기)\n\n\n\nFloggit을 입력하면 위와같은 화면이 나타나고 각 문서의 상태를 알수있다. Header가 변경되고, LICENSE가 삭제되었다.매번 명령어를 입력하기 곤란하니 단축키를 등록해보자.\n~/.local/share/lunarvim/lvim/lua/lvim/core/which-key/lua 파일에서 g (git) 키를 찾아 다음과 같이 수정해준다.\n\n이제 잘 동작한다."}},"/programming/neovim/git_shorcut":{"title":"Git Shorcut","data":{"":"깃 단축키는 위치키(플러그인)에 매핑되어있다.~/.local/share/lunarvim/lvim/lua/lvim/core/which-key/lua 에 설정되어있다.\n\n설정파일에 접근하기가 불편하니 다음과 같이 바로가기를 만들어두는 편이 좋다.\n\nLink를 만드는 방법은 다음과 같다.\n> ln -s ~/.local/share/lunarvim/lvim/lua/lvim ~/.config/lvim-origin"}},"/programming/neovim/hover_info(view_type)":{"title":"K (shift + k) 타입보기","data":{"":"여타 ide의 경우 추론된 혹은 명시된 타입을 보기위해서는 변수 위에 마우스를 올리면 나타난다.\n\n빔에서는 일반적으로 마우스를 사용하지 않기 때문에 키보드 맵핑을 통해 이를 해결하는데\n루나빔의 경우 타입이나 함수 시그니처를 보기위해서는 K 를 입력해주면 된다.\n\nKK 즉 두번입력하면 호버링된 인포메이션 창에 포커스를 옮길수 있다. 포커스가 뜨면 V비주얼모드로 라인복사하기 수월하다."}},"/programming/neovim/plugin-nvim-surround":{"title":" nvim surround plugin ","data":{"":"빔의 기본설정에는 브라켓을 씌우는 로직이 없어서 일일히 찾아가서 씌워줘야 한다.\nvscode나 다른 여타 IDE 를 사용하면 브라켓을 씌울 글자를 셀렉트하고\n브라켓을 입력하면 바로 입력된다. 키보드 입력은shift + opt + arrowkey + [\n이렇게 네번의 키입력이 있을때 작동한다.이번에 소개하는 플러그인은 해당 위치를 직접 찾아가서 브라켓을 씌우지 않고\n다른 IDE 에서 사용하듯이 적당한 키입력을 통해 브라켓을 씌워주는 플러그인이다.","설치#설치":"설치법은 깃헙페이지에서 제시한대로 다음과 같다.\nlvim.plugins = {\n{\n\"kylechui/nvim-surround\",\nversion = \"*\", -- Use for stability; omit to use `main` branch for the latest features\nevent = \"VeryLazy\",\nconfig = function()\nrequire(\"nvim-surround\").setup({\n-- Configuration here, or leave empty to use defaults\n})\nend\n}\n}\n/.config/lvim/init.lua 파일을 열고 위 설정값을 입력한 후 빔을 실행하면 플러그인 매니저인 Lazy가 자동으로 설치를 해준다.","사용법#사용법":"이후 메뉴얼에서 소개하는 사용방법을 통해 브라켓 씌우기, 브라켓 변형하기등의\n기능을 사용할 수 있다.\nOld text                    Command         New text\n--------------------------------------------------------------------------------\nsurr*ound_words             ysiw)           (surround_words)\n*make strings               ys$\"            \"make strings\"\n[delete ar*ound me!]        ds]             delete around me!\nremove <b>HTML t*ags</b>    dst             remove HTML tags\n'change quot*es'            cs'\"            \"change quotes\"\n<b>or tag* types</b>        csth1<CR>       <h1>or tag types</h1>\ndelete(functi*on calls)     dsf             function calls"}},"/programming/neovim/react_snipperts":{"title":"리액트 html 스니펫 활성화하기","data":{"":"루나빔을 처음 설치하고 리액트를 작성하면 얼마 지나지 않아 크게 당황하고 마는데, 이유는 돔 태그들에 대한 스니펫이 작동하지 않기 때문이다. 루나빔의 레이지 플러그인은 파일 확장자를 보고 자동적으로 언어관련 모듈을 설치해서 lsp나 코드하이라이팅을 지원해주는데, 리액트파일을 자바스크립트 파일로 인식한 나머지 리액트 스니펫을 작동시켜주지 않는듯하다.하지만 이미 내장플러그인들로 충분히 기능사용이 가능하기 때문에 약간의 설정만 변경해주면 무리없이 사용이 가능하다.~/.config/lvim/config.lua 파일을 열고 다음과 같은 설정값을 입력해주고 에디터를 리부트 시켜주자.\n\nlocal lspconfig = require('lspconfig')\nlocal configs = require('lspconfig/configs')\nlocal capabilities = vim.lsp.protocol.make_client_capabilities()\ncapabilities.textDocument.completion.completionItem.snippetSupport = true\n\nlspconfig.emmet_ls.setup({\ncapabilities = capabilities,\nfiletypes = { \"css\", \"eruby\", \"html\", \"javascript\", \"javascriptreact\", \"less\", \"sass\", \"scss\", \"svelte\", \"pug\", \"typescriptreact\", \"vue\" },\ninit_options = {\nhtml = {\noptions = {\n[\"bem.enabled\"] = true,\n},\n},\n}\n})\n\n이제 스니펫이 잘 동작할 것이다.설정파일이 커져 복잡해보인다면 루아파일 분리하기를 참고하자."}},"/programming/neovim/searchkeymap":{"title":"기능 단축키 검색하기","data":{"":"이번 팁은.. 사실 조금만 관찰해도 쉽게 찾을 수 있다. 위치 키에서 해당 기능을 소개해주고 있기 때문이다.빔의 단축키 명령어는 위치키(루나빔 기본내장)를 통해 수많은 조합으로 매핑될 수 있는데, 루나빔은 기본적인 셋팅값들이 제법 많이 매핑되어있다. 지금 소개할 키맵핑 정보 찾는 기능도 이미 매핑되어있다.루나빔에서 스페이스(빔에서는 리더키라고 부른다)를 누르고 약 0.5초간 기다리면 사용자가 학습이 덜 됐다는 판단하에 키기 어떤 구성인지 소개를 해준다.\n\n여기서 s가 서치인걸 확인할 수 있고 눌러보면 k에 키맵이 매핑되어있다고 나타난다. 해당 키를 누르면 다음과 같은 검색화면이 뜬다.\n\n검색어를 입력하면 해당기능에 대한 단축키를 찾아낼 수 있다."}},"/programming/neovim/use_custom_snippet":{"title":"커스텀 스니펫 사용하기","data":{"":"빔을 쓰다보면 스니펫 정도는 만들어서 쓸 수 있어야한다.스니펫 플러그인이 여럿있겠지만, 루나빔에 내장된 스니펫 플러그인을 사용하도록 하자.루나빔에서 사용하는 내장 스니펫 플러그인은 luasnip이라는 이름이다.\n이 플러그인은 vscode에서 사용되는 모든 스니펫을 다운로드해서 가져오고 사용할 수 있도록 도와준다.또 이 방식에 따라 커스텀 스니펫 또한 만들어 사용할 수 있다.\nrequire(\"luasnip/loaders/from_vscode\").load { paths = { \"~/.config/lvim/snippets/my-snippets\" } }\nrequire를 보면 알겠지만, 해당 스니펫은 vscode스니펫 설정을 로드하는 방식이다.\n해당 스니펫을 제작할때는 두가지 파일이 필요하다.\n{\n\"name\": \"wisnips\",\n\"author\": \"wis\",\n\"engines\": {\n\"vscode\": \"^1.11.0\"\n},\n\"contributes\": {\n\"snippets\": [\n{\n\"language\": [\"svelte\"],\n\"path\": \"./svelte.json\"\n}\n]\n}\n}\n\n{\n\"console log input\": {\n\"prefix\": \"clg\",\n\"body\": \"console.log(${0})\",\n\"description\": \"wisnip : console.log()\"\n}\n}\n\n바디에 ${0} 이 있는걸 확인할 수 있는데 스니펫불러오면 이 곳에 커서가 포커싱된다. 이후 ${1} ${2} ${3} 으로 탭키 누르면 자동으로 다음 항목으로 옮겨지기 때문에 유용하게 사용할 수 있다.\n두 파일 모두 json파일로 구성되어져있기 때문에 제이슨 형식에서 벗어나면 파싱에러를 일으키며 동작을 안할수도 있다. 특히 컴마, 사용에 주의하도록하자."}},"/programming/rust/basic_syntax/*rust_basic_syntex":{"title":"*rust Basic Syntex","data":{"":"1.hello_world\n2.comment\n3.primitive_types\nprint\ntraits\nown_burrow\nstring"}},"/programming/rust/basic_syntax/1.hello_world":{"title":"println 함수로 \"hello world\" 작성하기","data":{"":"","cargo-new프로젝트-생성#cargo new프로젝트 생성":"> cargo new hello_rust\n프로젝트를 생성하면 루트폴더에 다음과 같은 파일이 생성되어있다.\n이 파일을 통해 디펜던시를 관리할 수 있다.\n[package]\nname = \"hello_rust\"\nversion = \"0.1.0\"\nedition = \"2021\" # 현재시간이 아니라 카고의 버전을 뜻한다.\n\n[dependencies]\n실행파일로 이동해보자.\nfn main() {\nprintln!(\"hello, world!\")\n}","hello-world-컴파일과-실행#hello, world! 컴파일과 실행":"기본셋팅값으로 헬로월드 출력문이 작성되어있다.\n개별 파일을 실행할때는 개별로 컴파일 하고 이후 바이너리 파일을 직접\n실행시켜줄 수 있다\n> rustc src/main.rs\n> ./main\nhello, world!\nrustc 명령어를 통해 코드를 컴파일하고이를 실행하려면 빌드하고 컴파일된 파일을 실행해줄 수 있으나,\n러스트의 cargo는 이 두 과정을 한번에 처리할 수 있는 구문을 제공하고 있다.\n> cargo run\nhello, world!"}},"/programming/rust/basic_syntax/2.comment":{"title":"주석","data":{"":"","블럭-주석#블럭 주석":"일반적인 주석은 슬래시 // hello로 사용한다.\nfn main() {\n// hello rust\nprintln!(\"hello, world!\")\n}","인라인-주석#인라인 주석":"러스트의 인라인 주석은 다음과 같이 사용한다.\n/* hello */\nfn main() {\nlet x/*: i16 */ = 10;\n}"}},"/programming/rust/basic_syntax/3.primitive_types":{"title":"타입","data":{"":"","원시타입-스택#원시타입 (스택)":"양의 정수 (unsigned integer)\nu8  : 0 ~ 255\nu64 : 0 ~ 18,446,744,073,709,551,615\n\n\n정수 (signed integer)\ni8 : -128 ~ 127\ni64 : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\n\n\n부동소수점\nf32 : -3.4_10^38 ~ 3.4_10^38, 대략 소수점 이하 7자리 수 -> 잘 안씀\nf64 : f32대비 속도차이가 잘 나지않아 자주 씀\n\n\n논리 : true / false\n문자 : 'a', 유니코드, u8과 호환 => 형변환 가능\nlet x:u8 = 100; print!(\"{}\", x as char); => d","복합타입-힙#복합타입 (힙)":"문자열 (문자타입의 집합 - 원시타입일수 없음)\n&str : \"hello\", 레퍼런스타입, 소유권이 없음\nString : \"hello\".to_string(), String::from(\"hello\"), 소유권있음\n\n\n튜플 : ('a', \"hello\", 32)\n배열 : [1, 2, 3, 4, 5] 배열의 내부는 같은 타입들로 구성\n구조체\n열거형\n클래스"}},"/programming/rust/basic_syntax/own_burrow":{"title":"소유권 (for safety)","data":{"":"","owned-dataname#owned data(name)":"모든 데이터는 어느 한 시점에 반드시 하나의 소유자를 갖는다. 소유자는 주로 변수이다.\n모든 데이터는 태어나는 시점과 소멸하는 시점이 한번씩만 있다.\n모든 데이터의 소유권은 어느 한 소유자에게서 다른 소유자로 이전될 수 있다.\n모든 데이터는 특수한 상황에서 공동 소유자가 존재할 수 있다.\nheap","burrowed-dataname#burrowed data(&name)":"다른 소유자에게서 빌려온 데이터\n어느 한 소유자는 자신의 데이터를 무한히 반복하여 빌려줄 수 있다.\n빌려주는 사람(소유자)는 반드시 빌려간 사람보다 오래 살아야한다.\nstack"}},"/programming/rust/basic_syntax/print":{"title":"프린트 함수","data":{"":"","-출력#\"{}\" 출력":"러스트의 프린트 함수는 다음과 같이 사용된다\nlet x = 100;\nprintln!(\"{}\", x);\n\n100\n이때 프린트는 위와같은 방식으로 x라는 변수를 받아서 출력된다. x의 값은 정수로 잘 출력된다.","-display-trait-debug-trait#\"{:?}\" Display Trait, Debug Trait":"let x = vec![1,2,3,4];\nprintln!(\"{x}\")\n---> err\n\nprintln!(\"{:?}\",x)\n---\n[1,2,3,4]\n러스트에서는 벡터나 배열같은 복합타입을 print할 때 특정 조취를 취하지 않으면 다음과 같은 오류를 나타낸다.\nrustc: `Vec<{integer}>` doesn't implement `std::fmt::Display`\n// 벡터타입은 디스플레이를 구현하고 있지 않습니다.\nthe trait `std::fmt::Display` is not implemented for `Vec<{integer}>`\n// 디스플레이 트레이트는 벡터유형에 구현되지 않았습니다.\nin format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead [E0277]\n// 포멧 스트링에서 `{:?}`를 사용하거나 `{:#?variable}`을 사용할 수 있습니다.\n여기서 두가지 개념(트레이트와 프린트)에 대한 힌트가 나오는데 트레이트는 타입에 구현되어 사용되어지는것으로 이해할 수 있다. 만약 벡터유형에 디스플레이 트레이트가 구현되어져 있었다면 프린트함수에서 잘 출력될것으로 생각할 수 있고, 디스플레이 트레이트가 없지만 벡터유형의 경우 스트링 포멧이 필요할 때 {:?}를 사용할 수 있다는 점이다.즉 프린트함수는 스트링 포멧을 출력하기 위한 함수로 볼 수 있고, {:?} 를 사용하여 벡터유형을 스트링포멧으로 변환시켜준다고 이해할 수 있다.이때 \"{:?}\"는 출력대상(벡터) 유형이 가진 디버그 트레이트를 대상으로 한다.트레이트에 대한 추가설명은 traits에서 확인하자.","x-프리티-프린트#\"{x}\" 프리티 프린트":"원래 프린트 함수는 println!(\"{}\", x)꼴로 작동하지만 최근 러스트에서 프리티 프린트 기능이 추가되어 println!(\"{x}\")꼴의 형태도 출력을 지원하게 되었다.","p-포인터-메모리-주소#\"{:p}\" 포인터 (메모리 주소)":"let a = 10;\nlet b = &a;\nprintln!(\"{:p}\", b);\n---\n0x16cfe29dc\n러스트에서는 포인터 출력을 할 수 있는데 참조형 자료를 출력할때 해당 메모리가 어딨는지 찾아낼 수 있다.","기타-출력-형식들#기타 출력 형식들":"\"{:x}\" hexadecimal\n\"{:o}\" octal\n\"{:b}\" binary\n\"{:%}\" percent\n\"{:,}\" 큰수 천단위 구분자\n\"{:.2f}\" 소수점 두자리\n\"{:.*f}\" 소수점 출력"}},"/programming/rust/basic_syntax/string":{"title":"문자열","data":{"":"","str#&str":"레퍼런스 스트링 타입은 데이터가 스택에 보관된다.\n레퍼런스 스트링은 다음처럼 사용할 수 있다.\nlet x = \"hello world\";\n레퍼런스 스트링타입은 레퍼런스의 특징을 고스란히 갖고 있다.\n\"hello world\"라는 데이터를 레퍼런스로 소유권을 빌려왔기 때문에 다른곳에서 사용한다고 해도 어딘가에 있는 소유권이 소멸되지 않는다. 즉 변수가 소유권을 관리하지 않기 때문에 여러번 반복사용해도 문제가 없다.\nlet x = \"hello world\";\nprintln!(\"{x}\");\nprintln!(\"{x}\");\n---\nhello world\nhello world\n타입을 알아보면 다음과 같이 표시된다.\n\n명시된 타입을 보면 사이즈와 주소값이 나타나는데, 주소값은 스택영역에서 관리한다.","string#String":"std::string::String : std library, string module, String structureString 타입을 사용하는 방식은 다음 두가지 방식이 대표적이다.\nlet a = std::string::String::from(\"string\");\nlet b = \"string\".to_string();\n첫번째 방법은 String 구조체가 가진 from 트레이트를 이용해 문자열을 정의하는 방법이고 두번째 방법은 to_string()메서드를 통해 레퍼런스 스트링값을 String으로 변환시키는 방법이다. 구조체를 use하지 않고도 사용할 수 있어서 편리하다.","소유권의-위임-새로운-변수에-할당-매개변수로-사용#소유권의 위임 (새로운 변수에 할당, 매개변수로 사용)":"String타입은 구조체에 의해 정의된 타입으로 힙영역에 존재하는 데이터다. (3.primitive_types) 또한 레퍼런스 타입이 아니기 때문에 할당 변수가 소유권을 갖게 된다. 변수의 소유권은 함수에게 위임하거나 다른 변수에게 위임하는 순간 제거된다.소유권이 제거된다는 말은 실제로 이전 변수가 갖고있던 주소값과 주소값이 가리키는 스택의 주소값 모두가 메모리에서 삭제된다는 뜻이다.\nlet x /* 주소값을 스택에 보관 소유권 없음 */ = \"hello world\";\nlet y = x; // 주소값 복사\nprintln!(\"{x}\"); // hello world\nprintln!(\"{y}\"); // hello world 모두 잘 출력\n\nlet a /* 주소값과 소유권을 스택에 보관 */\n= \"string\".to_string(); // 힙영역에 구조체로 저장되어있음\nlet b = a; // 주소값 복사, !소유권 위임!\nprintln!(\"{a}\"); // 데이터에 대한 소유권이 없기 때문에 오류\n---> err\nrustc: borrow of moved value: `a`\nvalue borrowed here after move [E0382]\n\n변수\t변수의 주소값\t스택\t힙\tx : &str\t0x001\t\"hello world\"\t\txr\t0x002\t0x001\t\ty\t0x003\t\"hello world\" (할당과 동시에 복사됨)\t\tyr\t0x004\t0x002\t\ta : String\t0x005 (양도시 삭제)\tString{address: 0x22} (양도시 삭제)\t\"string\"\tb : String\t0x006\tString{address: 0x22}","size#size":"&str 타입의 사이즈와 String 타입의 사이즈를 조사해보자\nfn main() {\nuse std::mem::{size_of, size_of_val};\n\nprintln!(\"{}\", size_of::<String>()); // 24\nprintln!(\"{}\", size_of::<&str>()); // 16\nprintln!(\"{}\", size_of_val(\"hell\")); // 4\nprintln!(\"{}\", size_of_val(\"hello world hlsdhfkshdfklsadflksafdkhklhaksfdklklhaksdfkalsdhfklha\")); // 64\n}\n사이즈 오브 함수를 이용해서 메모리 사이즈를 조사해보면 문자열의 사이즈는 가변사이즈라는것을 알 수 있다.String 타입은 스택메모리에서 고정된 크기를 가진다고 한다. 그래서 sized type이라고 부르고\n&str 타입은 스택메모리에서 가변적 크기를 가진다고 하여 not sized type이라고 부른다고 한다."}},"/programming/rust/basic_syntax/traits":{"title":"Traits","data":{"":"트레이트는 여러 타입들간에 공통적으로 동작하는 인터페이스로\n함수나 메서드\n타입\n상수\n로 구성된다.\n\n트레이트의 상당수는 어떤 기능이나 작동을 의미한다고 한다.","예1#예1":"예를 들어 print 문서에도 나와있는 std::fmt::Display(스탠다드 라이브러리, 포멧 모듈, 디스플레이 트레이트) 트레이트는 출력되기 위해 필요한 트레이트이다. 프린트로 사용하고 싶다면 디스플레이나 디버그 트레이트를 구현해야한다.","예2#예2":"#[allow(unused_variables)]\n함수 위에 위와같은 어노테이션?을 추가할 수 있는데 unused_variables트레이트를 허용하는 어노테이션으로 해당 함수의 블럭안에서 사용되지 않는 함수가 있어도 컴파일러가 경고를 띄워주지 않는 기능을 한다.","하스켈#하스켈":"하스켈에서는 타입클래스라는 이름으로 동일한 역할을 한다고 한다."}},"/programming/rust/mini_project/0.mini_project(with_chatgpt)":{"title":"러스트로 코드짜기","data":{"":"새로운 언어를 학습할 때 무슨 과제를 해야 효과적으로 학습이 될까? 이런 아이데이션이 필요할때는 인공지능의 도움을 받는게 좋다. 챗지피티에게 물어보았다.\"러스트를 이제막 시작하는 러린이야. 러스트를 효과적으로 학습하기 위해 작은 프로젝트를 해볼수있으면 좋겠는데 아주 아주 쉬운 과제들을 리스트업해줘\"\n러스트를 효과적으로 학습하기 위해 다음과 같은 간단한 프로젝트들을 시도해볼 수 있습니다:\n\n1. 구구단 출력: 1부터 9까지의 숫자에 대해 구구단을 출력하는 프로그램을 작성해보세요.\n2. 소수 찾기: 주어진 범위 내의 모든 소수를 찾아 출력하는 프로그램을 작성해보세요.\n3. 팩토리얼 계산: 주어진 숫자의 팩토리얼을 계산하는 프로그램을 작성해보세요. 여기에서는 순환(recursion)의 개념도 함께 고려해보세요.\n4. 피보나치 수열: 주어진 개수만큼의 피보나치 수열을 출력하는 프로그램을 작성해보세요.\n5. 문자 카운트: 문자열을 입력받아 각 문자가 몇 번 등장하는지 세서 출력하는 프로그램을 작성해보세요.\n6. 텍스트 파일 다루기: 텍스트 파일을 열어서 대문자와 소문자를 서로 바꾸고, 파일에 쓰여진 빈 줄을 세는 기능이 있는 프로그램을 작성해보세요.\n7. 구조체 활용: 학생 데이터(이름, 나이, 성적)를 저장할 수 있는 구조체를 작성하고, 여러 학생들을 벡터에 추가한 후, 성적 기준으로 정렬하는 프로그램을 작성해보세요.\n8. 온도 변환기: 섭씨 온도를 화씨 온도로, 또는 그 반대로 변환해주는 프로그램을 작성해보세요.\n9. 간단한 계산기: 두 개의 숫자와 기본 사칙연산을 입력받아 그 결과를 출력하는 프로그램을 작성해보세요.\n10. 직사각형 구조체: 가로 세로 길이를 가진 직사각형 구조체를 생성하고, 면적과 둘레를 계산하는 메소드를 작성해보세요.\n\n이러한 프로젝트들을 진행하면서 러스트의 기본 문법뿐만 아니라, 변수, 제어문, 함수, 루프, 구조체, 열거형(enum), 모듈, 에러 핸들링, 트레이트 등 여러 주제에 대해 접할 수 있게 됩니다. 각 프로젝트를 완료한 후 다양한 방식으로 개선하거나 확장해보세요. 이를 통해 러스트를 더 잘 이해할 수 있을 것입니다.\n이 과제들을 하나씩 수행해보자."}},"/programming/rust/mini_project/1.multiplication":{"title":"과제 1. 구구단 출력","data":{"":"fn print_multiplication(x: u32, y: u32, result: &mut Vec<String>) {\nresult.push(format!(\"{x}*{y}={}\", x * y));\nmatch y {\n9 => (),\n_ => print_multiplication(x, y + 1, result),\n}\n}\n\nfn print_multiplication_table(x: u32, result: &mut Vec<String>) {\nprint_multiplication(x, 1, result);\nmatch x {\n9 => (),\n_ => print_multiplication_table(x + 1, result),\n}\n}\n\nfn main() {\nlet mut result = vec![];\nprint_multiplication_table(1, &mut result);\nprintln!(\"{:?}\", result)\n}"}},"/programming/tauri/*tauri":{"title":"타우리","data":{"":"타우리는 프론트엔드 기술스택으로 모바일 데스크탑 등 크로스 플랫폼 앱의 제작을 도와주는 도구이다. 비슷한 플랫폼으로 electron을 볼 수 있는데, 타우리만의 장점이 몇가지 있다\n러스트 기반이다\n러스트는 널리 알려진대로 매우 빠르고 효율적인 언어다. 특히 러스트는 가비지컬렉터를 사용하지않고 코드에 의해 수동으로 관리되는데, 이때문에 개발자가 더욱 신경써야 하는만큼 메모리 사용이 효율적이다.물론.. 타우리의 프론트엔드는 리액트나 스벨트등으로 브라우져를 이용하여 동작하므로 이부분에 대한 메모리절감은 없다.\n프론트엔드 기술스택으로 데스크탑앱을 쉽게 만들수 있다\n이게 핵심이다. 웹에서 프론트 개발만 하던 사람이 데스크탑앱을 제작할 수 있다. 모바일 버전은 아직 0.5.1버전으로 베타중이다.\n패키지 사이즈가 매우매우 작다.\n타우리로 앱을 만들어 빌드한 결과가 아주 충격적이었다. 3메가바이트. 일렉트론으로 빌드하게 되면 150메가 바이트정도가 필요하다. 근본적인 차이가 있는데, 타우리는 브라우져를 패키지에 내장하지 않고 os의 기본브라우져를 빌려와서 사용하는 개념이다. 그렇다보니 패키지가 매우매우 작다.","api#api":"타우리를 사용하기 위해서는 프론트엔드의 코드를 SSR로 작성해서는 안된다. 그도 그럴게, 프론트엔드 서버를 굳이 운용할 필요가 없기 때문이다. CSR 혹은 SSG로 작성하게 하고, 서버사이드가 필요한 모든 요소들은 아래 타우리 API의 도움을 받아야 한다.(현재 파일시스템 문서만 작성)\napp\ncli\nclipboard\ndialog\nevent\nfs : 작성완료\nglobalShortcut\nhttp\nmocks\nnotification\nos\npath\nprocess\nshell\ntauri\nupdater\nwindow\n\n필자는 데스크탑에서 문서관리 도구를 만들고 있기 때문에 핵심 api로 파일시스템을 사용하고 있다."}},"/programming/tauri/api_fs":{"title":"file system","data":{"":"타우리의 파일시스템을 사용하려면 타우리 설정파일에 사용할 api를 명시해줘야 한다.\n{\n\"tauri\": {\n\"allowlist\": {\n\"fs\": {\n\"all\": true, // 사용여부 true\n\"readFile\": true,\n\"writeFile\": true,\n\"readDir\": true,\n\"copyFile\": true,\n\"createDir\": true,\n\"removeDir\": true,\n\"removeFile\": true,\n\"renameFile\": true,\n\"exists\": true,\n\"scope\": [\"$DOCUMENT/**\"] // 접근할 디렉터리를 지정\n}\n}\n}\n}","scope-디렉터리-접근성#scope 디렉터리 접근성":"\"scope\": [\"$DOCUMENT/**\"]타우리는 사용자의 pc를 보호하기 위해 pc내 절대경로나 상위디렉터리 (../) 를 허용하지 않는다. 읽기 또는 쓰기가 가능한 디렉터리 스코프를 성정해줄때 위 옵션을 사용한다.문서폴더 외에 가능한 스코프는 여기를 참고하자.","readtextfile#readTextFile":"읽기 api들이 몇가지 있지만 문서작업시 필요한 데이터는 역시 텍스트 데이터다. 텍스트 읽기 함수의 시그니처와 사용예제는 다음과 같다.\nreadTextFile(filePath: string, options?: FsOptions): Promise<string>\n\nimport { readTextFile, BaseDirectory } from '@tauri-apps/api/fs';\nconst contents = await readTextFile(\n'path/file.json',\n{\tdir: BaseDirectory.Document }\n); // utf-8\n스코프에서 설정한 폴더는 BaseDirectory 이넘를 통해 접근가능하다.","writetextfile#writeTextFile":"쓰기 api도 읽기와 별반 다르지 않다.\nwriteTextFile(path: string, contents: string, options?: FsOptions): Promise<void>\n\nimport { writeTextFile, BaseDirectory } from '@tauri-apps/api/fs';\nawait writeTextFile(\n'app.conf',\n'file contents',\n{ dir: BaseDirectory.Document }\n);\n이쯤되면 패턴이 명확해서 더이상의 설명은 필요없을듯 하다","removefile#removeFile":"import { removeFile, BaseDirectory } from '@tauri-apps/api/fs';\nawait removeFile('app.conf', { dir: BaseDirectory.AppConfig });","readdir#readDir":"import { readDir, BaseDirectory } from '@tauri-apps/api/fs';\n\nconst entries = await readDir('users', { dir: BaseDirectory.AppData, recursive: true }); // 재귀함수로 하위 폴더와 디렉터리를 모두 가져온다.\n\nfunction processEntries(entries) {\nfor (const entry of entries) {\nconsole.log(`Entry: ${entry.path}`);\nif (entry.children) {\nprocessEntries(entry.children)\n}\n}\n}","removedir#removeDir":"import { removeDir, BaseDirectory } from '@tauri-apps/api/fs';\nawait removeDir('users', { dir: BaseDirectory.AppData });\n바이너리 파일 읽기 쓰기도 있지만 생략"}}}