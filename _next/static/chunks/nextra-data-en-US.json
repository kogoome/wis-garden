{"/":{"title":"hello nextra","data":{"":"config is so simple!"}},"/katalk/learn_lang":{"title":"언어를 습득하는 오직 한가지 방법","data":{"":"한줄요약 :\n불안없이 자신감과 흥미를 가지고 이해할 수 있는 인풋을 제공받는 것\n\n\n\n프로그래머들에게도 언어학습의 묘는 동일하게 작용되는것같더라구요. 사실상 대부분의 학습은 언어적 차원에서 이루어지기도 하구요. 새로운 기술문서를 학습하는과정에서도, 새로운 프로그래밍 언어를 배우는 과정에서도 아 이정도면 어느정도 이해한것같은데 싶다가도 막상 내면화가 부족해 영상에서 말한 침묵의 시간속에 있는 자신을 발견하곤 하는데, 조급해할 필요없이 이해 가능한 인풋을 더 찾아봐야겟다 라고 생각하게 됩니다.교육학에서는 행동주의 인지주의 구성주의등의 다른 관점이 있는데, 인지주의적 측면에서 교육자들이 학생의 특성에 맞추려고 이런 저런 다양한 시도를 했으나 정답을 찾아내지못한 선생님들을 위로하는듯 느껴졌습니다. 저도 한때 학생마다 적합한 학습의 방법이 조금씩 다르지 않을까 하는 학습유형론에 빠져있기도 했구요. 열심히 설명해줘도 침묵하는 학생들의 반응에서 좌절할 필요가 없다고. 또 학생 입장에서 나는 수업을 열심히 이해하고 듣는데 왜 아무것도 못하지 라는 좌절감에 불안해할필요가 없다고, 위로해주는것같았네요.사용해보지 않은 기술을 써보려고 작은 사이드프로젝트를 했었는데 이제 막 프로그래밍을 부트캠프를 마친 사람 모였었어요.. 3주간 아무것도 못하고 강의만 듣는것같길래 뭐라도 작성해봐야하지 않겠나 라고 얘기했었는데.. 그것도 침묵의 시간이 아닐까 라고 생각하게 되더군요.제가 생각했을때 침묵의 시간은\n수학으로 치자면 정의를 이해하고 받아들이기, 정의와 예제 연결하기, 정의로부터 정리 연결하기 등의 사고활동들이 떠오르는데, 이런 내재적 연결성이 잘 형성되지 않은 모호한 시간을 말하는것같더라구요. 새로운 기술의 새로운 api를 보고 내부로직은 전혀 모르지만 몇가지 기능이 작동하는것만보고 내부로직을 추론하는 단계의 경우가 비슷한 케이스가 아닐까.. 정신모델이나 개념에 대한 스키마 형성이 잘 되어있지 않은듯 하다.. 라고 생각이 드네요.내부로직이 항상 드러난 수학과 달리 내부로직이 블랙박스처럼 가려진 학습대상들을 잘 이해하기 위해선 다양한 사용사례를 보고 블랙박스 내부를 채워가는 신경망학습과정이 필요한것같고 그 채움의 시간을 침묵의 시간으로 부르는것같다고 생각했습니다.이렇게 첫번째 인지 단계가 잘 해결된다면, 개념에 대한 스키마가 잘형성되고 정신모델이 확립된다면, 비로소 연결가능한 개념들을 더 상세히 인지할 수 있고 잘 연결시킬 수 있는 도구적 사고의 단계, 이해 이후의 적용과 응용 가정 추론 구조화 재구조화 변형 재정의 등 복잡한 단계로 넘어가게된다고 생각해용. 영상에서 말한 유일한방법이라는 강조는 아마 이런 형식적 사고의 단계이전에 정의적이해단계에서 관여하는것들에 한정된것같습니다."}},"/marblewriter_magazin":{"title":"구슬글방 매거진","data":{"":"세컨드브레인 커뮤니티 구슬글방 핵심멤버의 기고문은 여기에서 보실 수 있습니다.월간 구슬글방 매거진"}},"/marblewriter_magazin/expressions":{"title":"'비폭력 대화'와 말. 그럼 표정은?","data":{"":"","몸과-얼굴#몸과 얼굴":"우리는 대게 몸에 대해 기능적 해석을 갖고 있다. 예를들면 눈은 시각정보를 인지하기 위한 인지기관. 손은 무언가를 수행하기 위한 도구적 기관, 다리는 신체의 위치를 변경시키기 위한 기능기관 등으로 말이다.이런 해석에는 대체적으로 전제조건이 깔려있는데, 자신에게 어떤 기능을 수행하는지에 대한 것이다. 그런데 자신에게 어떤 기능을 수행하는가 보다 다른 사람에게 나 자신의 어떤 정보를 전달하기 위한 핵심 기관이 있다면, 그것은 얼굴이라고 볼 수 있다.얼굴은 거의 다른사람에게 보여지기 위해 기능하는 편이다. 특히 시선과 표정 말이 그렇다. 이번에 다룰 이야기는 말과 표정이다.","말과-표정#말과 표정":"다른 사람의 말을 듣고 영향을 받는 일은 종종 발생한다. 특히 다른 사람이 내가 관심있는 대상에 대해 말할 때 더욱 그렇다. 그런데 관심의 대상이 어떤 사람이라면, 우리는 말보다 표정을 더 중요하게 여기고는 한다.말은 소위 말하는 주체 화자의 의지와 사고가 반영되어있다. 그러나, 표정은 사고가 작동하기 이전에 이미 작동되어진다. 표정은 감정의 동요에 따라 즉각적으로 드러난다. 물론 표정도 사람의 성격에 따라 필터링 되어지는 정도의 여부는 각각 다르지만, 근본적으로 감정과 동기화되어있다는 점이 말과 다른점이다.그래서 우리는 말로부터 타인이 생각하는 방향에 대한 정보를 읽을 수 있는 반면, 표정으로부터 그들이 무엇을 느끼는지에 대한 정보를 얻어낼 수 있다.","표정의-발생과-표현#표정의 발생과 표현":"감정은 정보를 인지하는 가치기반 인지체계의 트리거로부터 신체적 반응이 유발되고, 책 회복탄력성의 저자이신 김주환 교수님이 말씀하셨듯이 반응적 신체 상태에 따라 뇌의 편도체를 중심으로 특정기억들이 연결 연상되며 우리 전두엽의 활성화와 상관없이 반응적으로 표정에 나타난다.즉 우리는 상대방의 표정을 통해 어떤 대상을 어떻게 느끼는지 추론할 수 있고, 네이처지에 발표된 연구에 따르면 표정을 16개로 분류할 수 있고 그것은 즐거움, 분노, 경이로움, 집중, 혼란스러움, 경멸, 만족, 욕망, 실망, 의심, 의기양양함, 흥미, 고통, 슬픔, 놀라움, 승리 등이라고 한다. 이 모든 감정을 다시 크게 묶는다면 긍정감정과 부정감정으로 나눌 수 있을것이다. 우리는 상대방의 표정을 통해 어떤 해석 대상이 긍정적인지 부정적으로 느끼는지 추론할 수 있으며 그로인해 상대방이 가진 가치체계 혹은 신념체계까지 깊게 대략적으로 추측 해낼 수 있다.반대로 우리는 타인에게 우리가 느끼는 정서를 표정으로 드러내며, 이는 우리 스스로 느끼는 대상에 대해 부정적인지 긍정적인지 가이드라인을 제공해줌으로서 나 자신이 부정적으로 대상 혹은 존재가 무엇인지 알리고, 상대방으로 하여금 가이드라인을 제공하는것과 같다.이 가이드라인, 즉 선을 잘 인지하는 사람들이 소위 눈치가 빠르다고 말한다. 표정을 나타내는 사람이 지금 어떤 인지정보를 생각하고 있고 여기에 대해 긍정적으로 혹은 부정적으로 생각하는지 정보를 판단하며, 긍정적이라면 해당 대상을 더 공급해주고, 부정적이라면 대상의 공급을 제한하거나 필터링하는 방식을 거치는 것이다.그런데 이 부정적 대상의 나 혹은 나의 일부 혹은 내 의지가 반영된 무엇일때 우리는 어떻게 느낄까?","표현과-관계#표현과 관계":"인간관계에 있어서 때때로 말보다 표정이 더 중요하게 작용할때가 있다. 우리는 말할 수 없는것에 대해서는 종종 말하곤 하지만, 대체로 표정 지을 수 없는것에 대해서는 표현하지 않는다. 표정은 말에 비해 소극적 표현이며, 표정을 나타내는 자의 의지를 직접적으로 드러내지 않고, 또한 표정은 잘 통제되지도 않기 때문이다. 표정은 대상의 정서적 인지와 동시에 즉각적으로 반응되어지는것으로, 느낌 자체를 즉각적으로 통제할 수 없는것과 마찬가지다.반면 말은 대게 전두엽이 활성화되어지며 이성적 사고 작동하에 발화자의 직접적 의지가 반영된다. 즉 말은 아주 적극적인 표현이라고 볼 수 있다. 때문에 말의 대상이 타인에게 향해있는 경우 발화자의 의지가 타인을 긍정적이나 부정적으로 평가하게 되며, 특이 이 부정평가는 공격성과 연결되어진다. 여기서 공격성에 대해 조금 더 생각해보자.아까 표정이 나타내는 가이드라인을 떠올려보자. 긍정적인 반응의 대상들을 한되 모아 가이드라인을 작성하고 내부를 긍정성의 원이라고 하자.긍정성의 내부에 속하는 모든 존재들을 뭉뚱그려 일컬어 ‘나’의 세계라고 할 수 있다. 긍정의 외부에는 부정의 대상들과 무관심의 대상들로 나눌 수 있고, 이들 사이에는 타인의 긍정성과 부정성이 있을 수 있다. 나의 세계에 속하지 않는 부정성들은 나에게 영향력이 없다. 하지만 내가 긍정하는 세계에 속하는 대상이 내가 긍정하는 존재를 부정하거나, 나 자신의 일부를 부정하게 된다면 내적 갈등이 생기게 마련이다.타인의 부정성을 긍정하고 받아들이게 되는 순간 내가 인지하던 긍정성의 세계에 균열이 발생하기도 하며, 때때로 나의 일부를 스스로 부정해내야만 한다. 만약 타인의 부정성을 부정한다면 타인이 부정성이 나타난 근원을 제거해야할것이다. 타인의 부정성이 표정을 제외한 말로 드러난것이었다면 대화를 통해 이성적으로 사유하고 평가하여 타인과 나의 세계관 자체를 조정하는 계기가 될 수 있다. 하지만 타인의 부정성이 말이아닌 표정에서 나타난것이라면, 혹은 말과 표정이 함께 작동했다면, 난관에 봉착하게 되는데, 타인이 무엇을 어떻게 느낄지는 나 자신이 영향력을 행사하기 쉽지 않기 때문이다. 연애관계처럼 감정 자체가 촛점이라면 시간을 들여 공을 들여 개선할 수 있겠지만, 가치관의 문제 세계관의 문제에서 비롯된 가치판단의 정서라면 당사자들이 살아온 세월만큼이나 변하기 어렵기 때문에 관계 자체가 재정의 되고는 한다.말의 공격성은 폭력적일 수 있지만 표정의 공격성은 파괴적 일 수 있는게 아닐까."}},"/marblewriter_magazin/search_path_for_concept_map":{"title":"영감과 대화, 경로탐색","data":{"":"","영감의-개념#영감의 개념":"우리는 각자가 학습한 대로의 개념을 갖고 있다. 여기서 개념이란 실제적이거나 추상적 관념의 한 단위로, 그 자체로 추상적이나, 어떤 다른 개념, 관념, 경험 연결될 때, 그 쓰임새를 보여주게 된다. 즉, 개념은 독립적이고 단독적으로 존재한다기보다 무언가와 연결되는 분기점의 역할을 하기도 한다.영감이란 개념 자체도 사용되는 맥락에 따라 해석이 달리 되게 마련이다. 영감이란 표현은 대게 종교나 예술에서 많이 사용되는데, 종교에서는 신이 내려준 지혜나 생각을 뜻하고, 예술에서는 창조적인 일의 계기가 되는 빼어난 착상이나 자극을 말한다. 그리고 우리는 대화하면서 영감을 얻는다는 표현을 종종 하게 된다.영감은 학습된 개념이 가진 연결경로 이외의 새로운 경로(한 개념의 새로운 시각 혹은 사용 방법)를 발견하게 되는 순간이거나, 혹은 기존의 연결경로를 수정하는 경우, 혹은 개념 자체의 정의를 수정하는 경우 등을 예로 들 수 있다. 이러한 변화를 총체적으로 다시 보면 영감은 결국, 인지된 개념이 변화되는 과정과 매우 연관이 깊다는 것을 알 수 있다. 개념변화의 과정은 학습 과정 그 자체를 의미한다.즉 영감은 학습의 본질 위에서 작동한다는 것을 알 수 있다.영감이 대화하면서 많이 발생하는 이유도 교수학습의 원리와 같다. 타인의 말을 집중해서 듣는 행위, 몰입해서 이해하는 과정을 통해, 타인이 사용하는 개념이 어떤 상황 어떤 맥락에서 무엇과 어떻게 연결 적용되는지를 이해하는 과정에서 내가 이전에 미처 학습하지 못한 사용성이나 시각을 깨닫고 이해하게 되고, 이를 통해 영감을 얻어 새로운 활동이 유발된다. 이 새로운 활동을 통해 기존의 개념에 새로운 시각과 연결되기도 하며, 기존의 연결 과정을 뒤엎어 내기도 한다. 이 과정 교육의 본질과 맞닿아 있다. 그래서, 교육의 상당 부분은 대화로 구성돼 왔다.학습의 관점에서 책이 더 많은 영감을 줄 수 있겠지만, 대부분 사람은 대화하면서 영감을 얻는다고 한다. 이유는 간단하다, 책은 나를 이해하고 피드백을 줄 수 없지만, 사람은 어느 정도 가능하기 때문이다. 그래서 책이 더 위대한 영감을 줄 수 있을지언정 독자를 고려해서 정보를 제공하지 않기 때문에 우리는 많은 영감을 대화에서 얻어낸다.그럼, 대화와도 같이 사람들에게 영감을 제공할 수 있는 수단은 없을까? 책처럼 모든 걸 다 읽어야만 이게 똥인지 된장인지 구별할 수 있지 않고, 사람처럼 나에게 필요한 영감을, 개념적 학습 가능 지점을 찾아낼 방법은 없을까?","택시와-네비게이션#택시와 네비게이션":"내비게이션이 없던 시절에는 택시 기사의 지식은 그 자체로 엄청난 가치가 있었다. 지금에야 택시의 지식보다 내비게이션을 더 믿는 시대가 되었지만, 내비게이션이 없던 시절, 지도과 위치에 관한 지식은 사회적으로 늘 높은 가치를 인정받아 왔다.더 이전의 시대로 거슬러 올라간다면, 지도가 없던 시대와 지도가 있는 시대로 나눠 생각해 볼 수 있는데, 지도가 없던 시대에는 유경험자의 지리적 정보의 가치가 매우 높은 평가를 받았다.\n상인들은 늘 사람들과 대화하며 어디에 어떤 물건이 있는지 어디에 어떤 물건이 필요한지 경험하여 학습하고 그 정보가 정확할수록 더 큰 부를 얻을 수 있게 되었다.\n그뿐만 아니라, 지리적 정보는 군사전략의 가장 핵심이 되는 정보다. 전쟁에 앞서 고지대를 미리 선점해 낸다면, 강한 이점을 가질 수밖에 없는 게, 각종 투사체의 사거리가 길어질 뿐만 아니라 전투 시 체력적으로도 우위를 점할 수 있었다.현대에 이르러 이런 지리적 정보를 데이터베이스에 넣고, 원하는 위치에 도달하는 최단 경로를 산출해 주거나, 최소시간경로를 추천받을 수 있게 되었다.하지만, 우리 교육은 아직도 전통 방식 그대로를 벗어나지 못하고 있다.교육은 개념이 변화되어 가는 과정이고, 개념은 연결가능한 경로의 한 분기점으로 추상화시킬 수 있다면, 개념에 대한 지도도 충분히 만들어 낼 수 있을 뿐만 아니라, 내비게이션도 만들어 낼 수 있다.비약이 있는데 비약을 채워보자. 개념이 왜 분기점이란 말일까?","개념과-문제해결#개념과 문제해결":"앞서 언급했듯 개념과 문제해결은 미로에서 길 찾기와 굉장히 연관이 깊다. 애초에 개념을 사고하는 뇌의 뉴런 연결구조 자체가 아주 복잡한 미로처럼 구성돼 있기 때문이다.우리가 무언가에 대해 생각하게 되면 생각의 경로를 따라가다 개념적 분기점에 이르게 되고, 분기점에서 한 경로를 선택하여 개념의 이어서 생각하곤 하는데 이 과정은 뉴런이 정보를 처리하는 과정과 일치한다. 뉴런은 자극받은 전기적 신호를 연결된 뉴런 중 특정 경로에 선택적으로 전기적 신호를 보낼 수 있고, 이때 활성화된 경로의 뉴런이 해당 경로와 연결된 회로를 가동하면서 집중의 요소를 한 방향으로 제한시킨다.우리 뇌는 무엇에 대해 생각하면서 끊임없이 분기점 사이에서 길 찾기를 하는 것과 같다. 그리고 문제해결을 잘 해내려면 개념이 가진 연결경로가 모두 학습되어 있을수록 유리하다.하나의 문제상황은 문제해결에 앞서 여러 가지 해답이 있을 수 있지만 아무 데나 가도 늘 문제를 맞힐수 있는 것은 아니다. 특정 방법들 안에서만 문제가 해결되는 경로가 존재하고, 그 경로의 분기점에는 이 개념을 어떻게 활용해야 할지, 어떤 방식으로 바라봐야 할지, 어떻게 활용해야 할지, 개념 사용의 경로를 선택해야만 한다.그래서 문제해결의 가장 중요한 점은 개념이 가진 경로의 전체적 특성을 얼마나 잘 이해하고 있는가, 이 시도가 먹히지 않는다면 어떤 시도를 할 수 있을 것인가? 라는 물음들의 연속과도 같다. 만약 개념학습이 잘 되어있지 않다면, 개념 연결성에 제한이 생기고 이 제한이 생긴 경로를 사용해야만 풀리는 문제에서 늘 막다른 골목에서 서성이게 될 수밖에 없는 것이다.이를 해결하기 위해 선인들은 그리고 성공한 사람들은 늘 책을 보라고 말하지만, 지식의 적합성이 늘 잘 맞는 것은 아니고 그러다 보니 당장 필요한 몇 가지 개념을 얻어내기 위해 해당 분야의 전문서적 10권 이상의 책을 학습해야만 한다.마치 내비게이션이 없던 시절에 전혀 모르는 곳에 도달하려고, 이 사람 저 사람 물어물어 열 사람 이상의 전문가에게 물어 정보를 취합해서 모험을 떠나는 것과 같다. 이게 작금 교육의 형태다. 전문가에게 물을 수 있으면 다행이나, 거의 무한대로 쏟아져 나오고 있는 수많은 강의들 사이를 여전히 떠돌아야만 한다.컨텐츠가 엔트로피의 법칙을 순리대로 따르며 무한히 증식하고 있는데, 우리 똑똑한 내비게이션은 증식하지 않는다. 그 비결은 정확한 데이터와 정확한 연산 처리에 있다. 미로 문제 풀이 알고리즘에 솔루션에 대한 힌트가 들어있는데, 핵심은 하이라키구조가 가지고 있다.","미로와-트리구조-경로탐색#미로와 트리구조 경로탐색":"위와 같은 미로가 있다고 해보자. 전체 그림을 보면 풀기 어렵지 않겠지만, 미로 안에 갇혀서 전체모습을 볼 수 없다면, 미로가 더욱 복잡해진다면 출구를 찾기 쉽지 않을 수 있다.문제해결에는 정해진 경로를 걸어나가는 능력과 분기점에서 선택할 수 있는 모든 경로를 인지하는 능력, 그리고 잘못된 경로로 들어섰을 때, 이전에 선택했던 경로가 무엇이었는지 기억하는 능력이 필요하다.이때 경로선택의 분기점을 개념이 필요한 상황이라고 볼 수 있었는데, 그림으로 표시하면 다음과 같다.\n\n빨간 블럭에서 파란 블럭으로 나아가고자 할 때 분기점을 모두 표시하면 그림의 녹색 블럭과 같다. 각 분기점은 경로를 선택해야 하며, 이때 분기점이 개념을 마주했을 때, 이 개념을 어떤 방식으로 연결시킬지 선택하는 과정이라고 볼 수 있다.만약 개념에 대한 학습이 덜 되어있어서 1번 분기점에서 아래로 가는 경로가 학습되어 있지 않다면 이 미로에서의 문제해결은 시작부터 어려움에 봉착하게 되는 것이다.\n\n\n뿐만 아니라 보통 문제상황은 중간 과정이 좀처럼 보이지 않는 경우가 많다.\n\n\n하지만 수많은 개념은 이미 대중에게 열려있고 정보의 바다 위에 떠돌아다니고 있다. 문제는 그 개념들이 잘 구조화되어 있지 않다는 것이다.인터넷에는 수많은 정보가 있지만 상당수가 구조화된 정보가 아니다 보니, 방대하게 복제되고 무분별하게 쏟아져나오고 있다. 현재 언어 학습 인공지능은 이런 문서들을 사람이 정제해서 가공된 데이터를 학습시키고 있지만 여전히 계층화된 정보는 아니라는 점에서 한계점이 있다.위의 미로처럼 명료하게 계층화시킬 수 있다면 보다 똑똑한 인공지능이 나오는 것은 자명하다.\n\n\n이 그림의 미로가 왜 계층화되어 있다는 걸까?\n각 분기점에서 이어지는 경로를 표시하면 위 그림과 같은데 이를 하이라키로 변환하면 다음과 같다.\n\n\n이런 문제상황에 있어서, '길을 찾는다', '방법을 찾는다', '영감을 얻는다'는 말은 위 계층구조의 각 분기점에서 어떤 방향으로 나아갈지 학습한다는 개념임과 동시에 새로운 시각을 얻는다는 말과 동일하다. 기존에 학습되지 않았던 지식에 새로운 문제해결의 출구가 열린다면 동기가 되지 않을 수 없다.컴퓨터 알고리즘은 이런 경로 탐색에 아주 효율적인 연산이 가능하다. 물론 모든 경로가 학습되어 있다는 전제조건 하에서 가능하다. 특히 하이라키 구조는 지식이 방대해져도 그 양이 점차 수렴되어 가는 양질의 정보 계층이기 때문에 연결성의 논리적 힘이 아주 강력하다고 볼 수 있다. 수학 문제를 해결할 때도 이 하이라키 경로 탐색과 정은 우리 머리속에서 그대로 나타나게 된다. 사실상 이 탐색 알고리즘 자체가 인간의 사고를 모방해서 만들었기 때문이다.위 문제는 중3 수학인데, 고등수학의 등비수열을 이용해서 문제를 풀어도 되지만 중2 기하학의 비례식을 이용해서 문제를 풀 수 있는데 풀이 과정은 다음과 같다.주어진 식으로부터  ,  로부터 다음 항이 될 때 1/3배씩 곱해진다는 패턴을 찾아내고,닮은 도형의 넓이의 비는 길이에 비의 제곱과 같다는 닮음 개념의 한 경로를 떠올려 닮음비를 찾아내고 과 정삼각형의 넓이 으로부터 한 변의 길이를 구하는 방정식 개념을 떠올려나온 결과물들을 연립방정식으로 연산하면 정답을 구할 수 있다.풀이에서와 같이 수학에서 문제해결은 각 개념의 활용을 선택하는 사전지식에 의해 문제해결에 대한 경로를 찾아내는 것과 같다. 또 수학은 엄밀하게 정돈된 하이라키 구조로 되어 있기 때문에 하나의 개념에 대해 모든 경로를 탐색했다면 더 이상 해당 영역에 대해 고민할 여지 자체가 없어지는 것이다.로지컬 싱킹, 박문호 박사님의 집합론적 사고, 직장인들이 배우는 MECE한 사고방식까지 모두 이 트리 구조적 사고방식을 논리의 베이스에 가져가고 있다.하지만 세상엔 트리 구조로 표현되지 않는 정보가 무수히 많다. 그럴 땐 어떻게 할까?","비선형-비-계층-구조-그래프-구조에서의-경로-탐색#비선형 비 계층 구조, 그래프 구조에서의 경로 탐색":"미로를 조금 더 변형시키면 아래와 같은 상황이 더 복잡하게 연결될 수 있게 되기도 한다.\n\n이 미로의 경우 계층구조로 회귀하지 않는 그래프구조를 띄고 있는데, 1번 분기점과 8번 분기점이 연결됨으로서 위 1번과 8번 중 어느 분기점이 상위구조인지 명확하지 않은 경우가 발생한다. 어떤 문제를 풀다 보니 다시 처음 상황으로 되돌아오는 경우를 말한다. 이런 아일랜드형 경로가 두세 개만 얽혀있더라도 자칫 잘못하면 길을 잃어버리기 십상이다. 이런 상황에서는 문제를 해결해 나가려면 목적지의 방향으로 경로를 우선 선택하되 지나간 경로는 길목에 표시해서 찾아나가야만 한다. 헨젤과 그레텔이 집에 돌아가기 위해 마크해 둔 것처럼.이런 상황은 컴퓨터가 더욱 전적으로 유리할 수밖에 없는데, 단시간에 모든 경로를 계산해서 최단 거리를 찾아낼 수 있기 때문이다. 심지어는 모든 경로를 탐색하지 않고도 최단 경로를 찾아내어 내비게이션처럼 길을 제공할 수 있다. 우리가 흔히 게임에서 목적지를 클릭하면 자동으로 경로 검색하는 알고리즘이 거의 실시간으로 연산 되어 즉각적으로 반응하는 모습을 볼 수 있기도 하다.하이라키가 논리적인 힘을 만들어 준다면, 하이라키가 아닌 비선형구조의 경로 탐색 기능은, 시각정보(내비게이션)를 제공하고 효율성(최단 거리)을 제공한다.학습에서 이런 서비스는 전문 선생님의 과외 말고는 방법이 없다. 즉 과외선생님이 해주는 교육 서비스는 지식에서의 경로 탐색 알고리즘에 가깝다는 말이다.","차세대-인공지능-교육-서비스#차세대 인공지능 교육 서비스":"현재 인공지능은 문자 단위로 구축되어 서비스되고 있다. 인터넷에 있는 글자들의 연관정보를 입력시켜 학습해 그래프 구조에서 나름의 내비게이션 역할을 문자 단위에서 해주는 서비스이다. 하지만, 문자 단위가 아니라 사고의 기본단위는 개념이기 때문에 개념의 연결이 카테고리 없이 연결되어 학습된 수준에서 언어모델이 아니라, 개념과 개념들이 어떻게 연결되어 있는지 충분히 잘 모델링된 데이터를 토대로, 생각의 경로를 온전히 제공해 주는 서비스가 나올 수 있을 것으로 기대한다.그렇게 하기 위해서는 보다 진보된 집단지성이 구축되어 있어야 하며, 현재의 위키백과를 뛰어넘는 더 양질의 집단지성의 장이 필요하다. 그리고 그 장에서는 하이라키와 그래프 연결이 구분되어 있어야 한다. 논리의 장 하이라키영역에서는 지식들이 끊임없이 수렴되어 최첨단의 지식과 연결되어 있으면서 동시에 생성의 장 그래프영역에서는 개인의 사소한 생각도 연결되며 확산되어야한다. 그러한 엄밀하면서 또 어설프거나 신선한 연결들의 총체는 우리를 더 나은 교육혁신의 현장으로 이끌 것이다. 굳이 인공지능이 아니라, 그냥 경로 탐색 알고리즘만으로도 말이다."}},"/programming/lunarvim/lunarvim":{"title":"루나빔","data":{"":"개발자라면 누구나 vi, vim, nvim 등을 쉽게 접하고 한번쯤은 써보게 된다.\nvim 은 아주 오래된 텍스트 에디터로 개발자에게 사랑받아왔던 개발도구인데,\n필자도 유튜브에서 빔을 이쁘게 꾸며놓고 프로그래밍을 멋지게 해내는 영상들을 보고\n한번쯤 써보고 싶다는 생각을 해왔다.이후 삽질의 시간을 거쳐 루나빔에 대해 알게 되었고 지금은 커스터마이징의 수렁에서 조금은 헤어나오게 되었다.\n루나빔은 neovim 이후로"}},"/programming/lunarvim/nvim-surround":{"title":" nvim surround plugin ","data":{"":"빔의 기본설정에는 브라켓을 씌우는 로직이 없어서 일일히 찾아가서 씌워줘야 한다.\nvscode나 다른 여타 IDE 를 사용하면 브라켓을 씌울 글자를 셀렉트하고\n브라켓을 입력하면 바로 입력된다. 키보드 입력은shift + opt + arrowkey + [\n이렇게 네번의 키입력이 있을때 작동한다.이번에 소개하는 플러그인은 해당 위치를 직접 찾아가서 브라켓을 씌우지 않고\n다른 IDE 에서 사용하듯이 적당한 키입력을 통해 브라켓을 씌워주는 플러그인이다.","설치#설치":"설치법은 깃헙페이지에서 제시한대로 다음과 같다.\nlvim.plugins = {\n{\n\"kylechui/nvim-surround\",\nversion = \"*\", -- Use for stability; omit to use `main` branch for the latest features\nevent = \"VeryLazy\",\nconfig = function()\nrequire(\"nvim-surround\").setup({\n-- Configuration here, or leave empty to use defaults\n})\nend\n}\n}\n/.config/lvim/init.lua 파일을 열고 위 설정값을 입력한 후 빔을 실행하면 플러그인 매니저인 Lazy가 자동으로 설치를 해준다.","사용법#사용법":"이후 메뉴얼에서 소개하는 사용방법을 통해 브라켓 씌우기, 브라켓 변형하기등의\n기능을 사용할 수 있다.\nOld text                    Command         New text\n--------------------------------------------------------------------------------\nsurr*ound_words             ysiw)           (surround_words)\n*make strings               ys$\"            \"make strings\"\n[delete ar*ound me!]        ds]             delete around me!\nremove <b>HTML t*ags</b>    dst             remove HTML tags\n'change quot*es'            cs'\"            \"change quotes\"\n<b>or tag* types</b>        csth1<CR>       <h1>or tag types</h1>\ndelete(functi*on calls)     dsf             function calls"}},"/programming/mac/hangul":{"title":"맥에서 한영키 전환 shift + space 로 변경하기","data":{"":"맥에서 한영키를 이런 저런 바인딩해서 사용하는 경우가 있는데,\ncapslock키로 바인드하는 경우 입력시간이 조금 길어지면 한영키 전환이 아닌\n대문자모드로 변경되는 경우가 있어 입력오타가 자주 발생한다.\n그렇다고 기본 변환인 ctrl + space 를 사용하자니 맥북 키보드에선\nfn 키 앞에숨어있어서 불편하고 외장키보드를 사용한다 해도 새끼손가락을\n제법 아래까지 내려야한다는 점에서 또 불편하다.구름 입력기를 사용하면 shift + space 키로 변경가능한 옵션을 제공하는데,\n모든곳에서 전혀 문제가 없지만 빔에서 사용시 띄어쓰기가 입력된다는점이다.다행히 맥에서는 핫키를 관리하는 파일이 있다. 해당 파일을 열어보자.","핫키파일#핫키파일":"그림처럼 파일이 깨져서 나오는데, 파일이 바이너리로 컴파일 되어있기 때문이다.\n이 파일은 xml 파일로 구성되어져 있으니 컨버팅이 필요하다.","컨버팅#컨버팅":"plutil -convert xml1 ~/Library/Preferences/com.apple.symbolichotkeys.plist","키설정-변경#키설정 변경":"파일이 잘 보이고 이제 문제의 한영키 셋팅에 가서 수정하면 된다.\n그림과 같이 61번 키의 내부 배열에서 마지막 숫자를 131072로 바꿔주자.\n저장하고 이후 다시 바이너리 파일로 컨버팅이 필요하다.","컨버팅-1#컨버팅":"plutil -convert binary1 ~/Library/Preferences/com.apple.symbolichotkeys.plist\n이제 맥을 리부트하면 한영전환이 변경된다."}},"/programming/rust/basic_syntax/1.hello_world":{"title":"println 함수로 \"hello world\" 작성하기","data":{"":"","cargo-new프로젝트-생성#cargo new프로젝트 생성":"> cargo new hello_rust\n프로젝트를 생성하면 루트폴더에 다음과 같은 파일이 생성되어있다.\n이 파일을 통해 디펜던시를 관리할 수 있다.\n[package]\nname = \"hello_rust\"\nversion = \"0.1.0\"\nedition = \"2021\" # 현재시간이 아니라 카고의 버전을 뜻한다.\n\n[dependencies]\n실행파일로 이동해보자.\nfn main() {\nprintln!(\"hello, world!\")\n}","hello-world-컴파일과-실행#hello, world! 컴파일과 실행":"기본셋팅값으로 헬로월드 출력문이 작성되어있다.\n개별 파일을 실행할때는 개별로 컴파일 하고 이후 바이너리 파일을 직접\n실행시켜줄 수 있다\n> rustc src/main.rs\n> ./main\nhello, world!\nrustc 명령어를 통해 코드를 컴파일하고이를 실행하려면 빌드하고 컴파일된 파일을 실행해줄 수 있으나,\n러스트의 cargo는 이 두 과정을 한번에 처리할 수 있는 구문을 제공하고 있다.\n> cargo run\nhello, world!"}},"/programming/rust/basic_syntax/2.comment":{"title":"주석","data":{"":"","블럭-주석#블럭 주석":"일반적인 주석은 슬래시 // hello로 사용한다.\nfn main() {\n// hello rust\nprintln!(\"hello, world!\")\n}","인라인-주석#인라인 주석":"러스트의 인라인 주석은 다음과 같이 사용한다.\n/* hello */\nfn main() {\nlet x/*: i16 */ = 10;\n}"}},"/programming/rust/basic_syntax/3.primitive_types":{"title":"원시 타입","data":{"":"양의 정수\nu8  : 0 ~ 255\nu64 : 0 ~ 18,446,744,073,709,551,615\n\n\n정수\ni8 : -128 ~ 127\ni64 : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\n\n\n부동소수점\nf32 : -3.4_10^38 ~ 3.4_10^38, 대략 소수점 이하 7자리 수 -> 잘 안씀\nf64 : f32대비 속도차이가 잘 나지않아 자주 씀\n\n\nboolean : true / false\n문자 : 'a'\n문자열\n&str : \"hello\", 레퍼런스타입\nString : \"hello\".to_string(), String::from(\"hello\")\n\n\n튜플 : ('a', \"hello\", 32)\n배열 : [1, 2, 3, 4, 5] 배열의 내부는 같은 타입들로 구성"}}}