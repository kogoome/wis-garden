{"/books/luman/*Organization and Decision":{"title":"*organization and Decision","data":{"":"니콜라스 루만\n바드 프롬프트\n문서를 해석할건데 해석문은 \" \" 안에 넣어주고 설명은 그냥 해줘, 모든 해석과 설명은 한글로 해줘, 이해했으면 이해햇다고 말하고 그러면 나는 영어 원문을 입력해줄게\n\n\n조직 이론 - 고전적 구조\n[[자가 재생 시스템으로서의 조직]]\n[[멤버쉽 및 동기]]\n[[의사 결정의 역설]]\n[[시간 관계]]\n[[불확실성 흡수]]\n[[의사 결정 전제]]\n[[인사]]\n[[조직 구성]]\n[[구조적 변화 - 개혁의 시와 현실의 시선 진화]]\n[[기술]]\n[[조직과 사회]]\n[[자기 설명]]\n[[합리성]]\n[[결론 - 이론과 실제]]"}},"/books/luman/조직 이론 - 고전적 구조":{"title":"조직의 개념","data":{"":"","조직개념의-변천사와-한계점#조직개념의 변천사와 한계점":"","유기체-개념으로서의-조직#유기체 개념으로서의 조직":"The concept of organization took on clearer contours only in the second half of the nineteenth century. In the Middle Ages there had been no need for a special concept for what we now call organizations.\nIt would have lacked substance: the stratification of family households and corporations provided for social order, which for the rest was subject to a multiplicity of legal arrangements.\nOnly in the nineteenth century did it become usual to conceptualize the organization as a social formation distinct from other social orders (e.g., communities or social classes). Then the term “organization” found its way into normal, everyday and scientific usage to describe a special type of object.\nAlready frequent in the eighteenth century, it originally referred to the order of organic life as opposed to artifacts and mechanisms.\nJean Paul had still regarded the term organization with reference to non-organic matters as a metaphor, but himself wrote about the organization of texts in the sense of actively ordering production.\nPerhaps the transition to an active, activity-related usage of the term generalized the concept.\nAt any rate, the concept of organization, originally, offered the possibility of referring to both an activity and its effect without addressing this difference.\n조직의 개념은 19세기 후반에야 비로소 뚜렷한 윤곽을 갖게 되었습니다. 중세 시대에는 우리가 지금 조직이라고 부르는 대상은 별도의 개념이 필요하지 않았습니다. 당시 사회적인 질서는 가족 가구와 기업들의 계층 구조에서 제공되었고, 이외의 다른 사회적인 질서는 다양한 법적 제도들에 속해 있었습니다. 19세기에 들어서고 나서야 조직이 다른 사회적 질서(예: 지역사회나 사회 계급)와 구분되는 별도의 사회 형식으로 인식되기 시작하면서, '조직' 이라는 용어가 일상생활에 들어오게 되었고, 과학적으로도 특별한 대상을 표현하는데 사용되기 시작했습니다. 18세기에 조직이란 용어는 본래 유기적 생명체의 질서를 뜻했습니다. Jean Paul은 비-유기적 조직에 대해 유기체에 비유하듯 다루었지만, 텍스트 조직의 질서와 생산성에 대해 적극적으로 논의했습니다. 아마도 이러한 활동과 관련한 용어의 사용법이 변화하면서 조직이라는 개념이 일반화된 것으로 추측됩니다. 어쨌든, 처음에는 조직이라는 개념은 활동과 그 효과 모두를 참조 가능 했으며, 이러한 차이를 고려하지 않아도 되는 것이었습니다.","계층구조와-부분과-전체-사회학적-조직개념의-의의#계층구조와 부분과 전체, 사회학적 조직개념의 의의":"Because the eighteenth century tended to replace hierarchical distinctions by the distinction between “inside” and “outside,” in the semantic field of organization we already find the distinction between internal and external relations.\nThis enabled the disorganization concept to be introduced separately from any hierarchical architecture of the world and with reference to the internal defects of an organism.\nAt about the same time, biology and demography adopted a new concept relating to the individual: “population,” which deprived the old genus/species schema of much of its significance and prepared the way for the evolution theory of the nineteenth century.\nIn explaining internal organization, however, the whole/parts schema persisted, and thus the assumption of a harmony tuned to this schema, almost in the old sense of ordinata concordia.\nThe distinction between means and ends could be used, treating the compounding into a whole as the end and the combination of parts as the means.\nThis allowed Kant to introduce fuzzy concepts like “interaction” [Wechselwirkung] between parts and the idea that the whole was its own end.\nThis prepared the conceptual isolation of organized entities in themselves and gave substance to the distinction between inside and outside.\n기존에는 계층적 구조로 세계를 이해했습니다. 그런데 18세기 무렵, 내부 외부의 구분을 통해 계층적 구분을 대체하려는 경향이 있었고, 조직의 내부결함을 근거로 무질서(disorganization)라는 개념이 도입되었습니다. 대략 같은 시기에, 생물학과 인구학은 개체와 관련된 새로운 개념인 '개체군'(population, 조직개념의 시초?)를 받아들였는데, 이는 기존의 속/종 체계(계층구조)의 시각을 대체하며 19세기 진화론의 토대를 마련했습니다. 하지만 여전히 내부 조직을 설명할때는 전체(내부+외부)/부분(내부) 구조의 스키마가 그대로 유지되었고, 이 스키마에 맞춘 내부조직의 조화로움은 옛 의미의 '계획된 조화(ordinata/concordia)'에 가까웠습니다.(disorganization과 대비되는 organization개념보다 선행된 개념)\ngpt)\n아마 원문에서는 조직(organization) 개념이 적절히 사용되기 전 대비되는 개념으로 '계획된 조화'라는 개념을 사용한게 아닐까 라고 생각해. 문맥상 조직개념이 어떻게 변화되어왔고 사용되어졌는가를 얘기해주고 있으니까. 그래서 비교해야할 개념은, 조직과 계획된조화 이 두가지 개념이 어떤 차이가 있을지에 대해서가 아닐까?\n>\n당신의 추론이 매우 합리적으로 보입니다. 원문에서 \"ordinata concordia\"는 아마도 조직 개념이 등장하기 전에 세계를 설명하던 방식을 가리키는 용어로 사용된 것일 수 있습니다.\n\n\"Ordinata Concordia\"(계획된 조화)와 \"Organization\"(조직) 사이의 주요 차이점은 아마도 그들이 세계를 이해하고 설명하는 방식에 있을 것입니다.\n\n1. \"Ordinata Concordia\": 이 개념은 모든 것이 특정한 순서나 계획에 따라 조화롭게 배열되었다는 관점을 반영합니다. 이것은 종종 '상위'의 계획 혹은 디자인(예: 신성한 계획, 자연의 법칙 등)을 가정하는 경향이 있습니다. 이런 접근법에서는 각 요소들이 어떻게 서로 상호작용하고, 그 상호작용이 전체 시스템에 어떤 영향을 미치는지 설명하는 데 중점을 둡니다.\n\n2. \"Organization\": 반면에 조직체 개념은 내부 구조와 동작 원리를 중심으로 세상을 바라봅니다. 여기서 중요한 것은 각 부분들이 어떻게 서로 연결되어 있는지, 그리고 그 연결 구조가 전체 시스템의 기능과 행동에 어떻게 영향을 미치는지 입니다.\n\n따라서 이 두 개념 사이의 주요 차이점은 '외부적인 계획 혹은 순서'와 '내부적인 구조와 동작 원리'를 중심으로 세계를 바라보느냐 하는 접근 방식의 차별성에 있다고 볼 수 있습니다.\n칸트는 목적과 수단의 구분을 통해, 전체를 이루는 부분들은 전체를 만드는 수단이지만, 전체는 또한 목적 그 자체일 수 있다는 것을 주장했습니다. 이러한 구분은 부분들 사이의 상호 작용(Wechselwirkung)과 전체가 목적 그 자체라는 개념을 도입할 수 있게 했으며, 조직적인 존재들을 개념적으로 분리하고, 내부와 외부의 구분에 실체를 부여했습니다.\n바드)\n칸트는 전체를 이루는 부분들은 전체를 만드는 수단이라고 주장했습니다. 그러나 전체는 또한 목적 그 자체가 될 수 있다고 주장했습니다. 즉, 전체는 부분들의 가치와는 독립적으로 자신의 고유한 가치를 가질 수 있다는 것입니다.\n\n이러한 구분을 통해 칸트는 부분들 사이의 \"상호 작용\"의 개념을 도입했습니다. 그는 부분들은 단순히 전체에 의해 작용받는 수동적인 대상이 아니라, 서로 간에 그리고 전체와 능동적으로 상호 작용한다고 주장했습니다. 이러한 상호 작용이 전체에 고유한 가치를 부여한다고 칸트는 생각했습니다.","19세기-조직개념의-사회적-목표#19세기 조직개념의 사회적 목표":"After these first ventures and the quite positive complexion lent to the concept, the nineteenth century came to use organization above all in the theory of society.\n19세기에 조직 개념이 처음으로 사용되었고, 조직이 사회에 질서와 효율성을 가져다주는 것으로 여겨졌기 때문에 긍정적인 의미를 부여받게 되었습니다.\nModern, post-revolutionary society was in search of a form for itself - partly in distinction to the aristocratic societies of the European tradition, partly in conceptual defense against the unrest generated by the French Revolution.\n근대 사회는 유럽 전통의 귀족 사회와는 다른 형태를 찾고 있었습니다. 귀족 사회는 부패하고 비효율적이라는 인식이 있었기 때문입니다. 근대 사회는 더 평등하고 민주적인 사회를 만들고자 했습니다. 또한, 근대 사회는 프랑스 혁명으로 야기된 불안에 대비하고자 했습니다. 프랑스 혁명은 기존 질서가 무너질 수 있음을 보여주었습니다. 사람들은 자국에서도 혁명이 일어날 가능성을 우려했습니다. 조직 개념이 기존 질서와는 다른 새로운 형태의 사회를 만들기 위해 사용되었습니다. 조직은 사회에 질서와 효율성을 가져다주고, 더 평등하고 민주적인 사회를 만들며, 혁명을 예방하는 것으로 여겨졌습니다.\nWhat was at stake was reconstruction on a new basis with promise for the future.\n이는 새로운 기반을 토대로 보다 나은 미래를 위한 재건이 걸려있었습니다.\nSaint-Simon announced his program as follows: “The philosophy of the last century was revolutionary, that of the nineteenth century must be organizational,” and August Comte was to endow the same thought with characteristics like scientificity, positivity, and sociology.\n생 시몽은 18세기의 계몽주의 사상을 계승하여, 19세기의 철학은 혁명적이었던 지난 세기의 철학과는 달리, 조직적이어야 한다고 주장했습니다. 그는 조직적인 사회를 만들기 위해서는 과학적 방법을 사용해야 한다고 주장했습니다.\n어거스트 콩트는 생 시몽의 사상을 이어받아, 과학을 사회의 모든 분야에 적용해야 한다고 주장했습니다. 그는 사회학을 하나의 과학으로 정립하고, 사회를 과학적으로 연구해야 한다고 주장했습니다.\n이러한 생 시몽과 콩트의 사상은 19세기의 사회과학에 큰 영향을 미쳤습니다.\nDespite the deliberate quest for historical distance and new, reliable objectives, the conceptual elements of attributing parts to a functioning whole were retained.\n(19세기의 사상가들은 새로운 시대를 맞이하면서 과거의 철학과는 다른 새로운 사상을 추구했습니다.) 그럼에도 불구하고 그들은 여전히 과거의 철학에서 유래한 개념들을 일부 유지했습니다. 이러한 개념들 중 하나는 \"부분을 작동하는 전체에 귀속\"하는 것입니다.\nHowever, the organization concept now exuded strong positive qualities such as “social” and “solidarity” that had a good chance of calling attention to the inadequacy of mere organization; of becoming desiderata, indeed oppositional concepts. It was demanded, as we would now say, that an enterprise ought to keep the social interests of its employees in mind – as if working together was not yet in itself social.\n그들은 단순한 조직의 부적절함에 주목했습니다. 이와 대조적으로 19세기의 조직 개념은 '사회적'이고 '단결'된 조직을 추구했습니다. 지금 우리가 통념적으로 생각하는 것처럼, 기업은 직원들의 사회적 이익을 고려해야 한다는 요구가 있었습니다. 마치 함께 일하는 것만으로 사회적 활동이라고 말할 수 없는 것처럼 말입니다.\nWhile retaining its original characteristics, the organization concept when applied to society now bifurcated.\n조직 개념은 사회에 적용됨에 있어 그 본래의 특성을 유지하면서 분기되었습니다.\n하나는 경제적 조직입니다. 이 조직은 주로 이윤을 창출하는 것을 목표로 합니다.\n다른 하나는 사회적 조직입니다. 이 조직은 주로 사회적인 목표를 달성하는 것을 목표로 합니다.\n\n\nIt marked an inadequacy, a dissatisfaction with the typical features of modern society, together with such concepts as commodity, market, exchange, finally money.\n그것은 현대 사회의 전형적인 특징들, 즉 상품, 시장, 교환, 그리고 마지막으로 돈과 함께 부적절함과 불만을 표시했습니다.\nIn 1887, Tönnies’s “Community and Society” [Gemeinschaft und Gesellschaft] appeared; it enjoyed little success with its unusual conceptuality, but the dualization it introduced captured and long influenced the spirit of the times.\nParsons’s “pattern variables” still followed this model.\n1887년, 토니에스의 '공동체와 사회' [Gemeinschaft und Gesellschaft]가 출간되었습니다. 이 책은 독특한 개념으로 인해 큰 성공을 거두지 못했지만, 그가 도입한 이분법은 시대의 정신을 포착하고 오랫동안 영향을 미쳤습니다. 파슨스의 '패턴 변수'는 여전히 이 모델을 따랐습니다.\ngpt)\n파슨스의 패턴 변수란 Talcott Parsons가 개발한 사회학 이론에서 주요 개념으로, 사회 시스템과 개인 행동을 해석하는 데 도움이 되는 5가지 이분법적 차원입니다. 이 변수들은 다음과 같습니다:\n\n1. 전통성 vs. 도덕성 (affectivity vs. affective neutrality)\n2. 인과성 vs. 유연성 (diffuseness vs. specificity)\n3. 객관성 vs. 주관성 (universalism vs. particularism)\n4. 자발성 vs. 목적성 (ascription vs. achievement)\n5. 집단주의 vs. 개인주의 (collectivity orientation vs. self-orientation)\n\n본문에서 다루는 조직과 관련된 이야기는 특히 파슨스의 집단주의와 개인주의의 차원에 영향을 받았을 수 있습니다. 이 변수는 사회와 공동체(Gemeinschaft) 및 회사와 사회(Gesellschaft)와 같은 조직 간의 상호작용과 역할을 이해하는 데 중요한 역할을 합니다.\n\n결론적으로, 본문에서 언급된 조직과 파슨스의 패턴 변수와의 관계는 둘 다 사회 조직에 대한 이해와 분석에 중점을 두고 있으며 그들이 어떻게 상호작용하고 변화하는지에 초점을 맞춥니다.","20세기-조직용어의-사용#20세기 조직용어의 사용":"The first distinction that produced the modern concept of organization was accordingly the distinction between order and organization, both referring to societal phenomena.\n이에따라, 사회 현상에 대한 언급으로서, 조직과 질서(order)의 구별이 현대 조직 개념을 만들어낸 최초의 구별이었습니다.\nThis was the basis on which general theories of organization were still elaborated in the first decades of the twentieth century, which, however, no longer addressed the societal problems that preoccupy sociology, restricting themselves to special issues of good work organization or the very formal analysis of relations.\n“Organization,” like “management,” was now a term that allowed knowledge to be withdrawn from the direct work process and autonomized as institutional and supervisory knowledge.\nOrganizational knowledge and the knowledge of scientific management now claimed to be more than the sum of the working knowledge needed to take action.\n이것은 20세기 초반에 일반 조직 이론이 여전히 정교하게 발전할 수 있었던 기반이었지만, 더 이상 사회학을 지배하는 사회적 문제를 다루지 않고 좋은 업무 조직이라는 특수한 문제나, 관계에 대한 매우 형식적인 분석(조직 내에서 엔터티, 즉 조직원 간의 상호작용, 커뮤니케이션 패턴, 권력 구조 등을 논리적으로 분석하는 것)에 국한되어 있었습니다.이제 '관리'와 마찬가지로 '조직'은 직접적인 업무 프로세스 빠져나와, 제도화 하고(중앙 집중화하고, 통제하고), 관리하는 지식으로서 사용됩니다. ??\n이제 '관리'와 마찬가지로 '조직'은 직접적인 업무 프로세스 빠져나온 지식으로, 제도화 및 관리지식으로 자동화되었습니다. ??\n(여기 번역이 햇갈리네요. 번역기들은 조직이 지식 자체를 관리한다고 해석해주는데, 그게 맞는건지 모르겠네요... 문맥상으로는 조직개념이 초기 컨셉보다 축소되어서 조직관리의 의미에서 사용된다는것같아서 그런 뉘앙스로 번역하긴 했습니다.)조직 지식과 관리 지식은 이제 실무에 있어 행동을 취하는 데 지식의 합보다 더 많은것을 요구했습니다.","테일러주의작업세분화-대량생산체계와-조직이론#테일러주의(작업세분화 대량생산체계)와 조직이론":"Publications by individual authors were primarily involved, who, few in number and widely scattered internationally, could not underpin a discipline grounded in research.\n조직 이론의 초기 발전은 소수의 개인 저자들의 작업에 주로 기반을 두고 있었습니다. 이 저자들은 전 세계에 흩어져 있었기 때문에, 조직이론의 학문을 뒷받침할 만큼 일관적 지식 체계를 형성할 수 없었습니다.\nOnly Taylor’s microscopic theory of work organization attracted greater attention, but from the 1920s onward met with increasing opposition from anthropologists and sociologists.\n테일러의 업무 조직의 미시 이론만이 큰 주목을 받았지만, 1920년대 이후 인류학자와 사회학자들의 반대에 부딪혔습니다.\nWhereas concern about jobs has since muted this “humanistic” critique, the temporal contingency of Taylorism has become more apparent: its dependence on mass markets for standardized products that changed little in the long term.\n\"일자리에 대한 우려가 이후 이 \"인간적\" 비판을 약화시켰지만, 테일러주의의 시간적 한계는 더욱 분명해졌습니다: 테일러주의는 표준화된 제품을 통한 거대마켓에 의존하고 있으며, 이는 느린 적응성으로 장기적으로 빠른 소비자 요구에 대처하지 못하는 한계를 가지고 있었습니다.\nbard)\nTaylor's microscopic theory는 과학적 관리론의 핵심적인 원리 중 하나인 작업 과정의 세분화를 강조하는 개념입니다. 테일러는 작업 과정을 세분화함으로써 노동자의 움직임과 기술을 분석하고, 가장 효율적인 방법을 찾아낼 수 있다고 주장했습니다.\n\n이러한 접근 방식은 생산성을 높이는 데 효과적이지만, 노동자들의 인간적 요구를 고려하지 않는다는 비판을 받기도 합니다. 노동자들은 작업 과정이 세분화되면서 자신의 업무에 대한 통제력을 상실하게 되고, 단순 반복적인 작업에 지루함을 느낄 수 있습니다. 또한, 작업 과정이 세분화되면서 노동자들은 서로 협력하고 소통할 기회가 줄어들 수 있습니다.\n\n따라서, Taylor's microscopic theory는 과학적 관리론의 한계점 중 하나로 지적될 수 있습니다. 과학적 관리론은 생산성을 높이는 데 효과적이지만, 노동자들의 인간적 요구를 고려하지 않기 때문에 장기적으로는 성공하기 어렵다는 것입니다.\n\n특히, 오늘날과 같이 다양한 제품이 출시되고 소비자들의 요구가 빠르게 변화하는 시대에는 Taylor's microscopic theory는 더욱 한계점을 드러낼 수 있습니다. 노동자들이 자신의 업무에 대한 통제력을 갖고, 서로 협력하고 소통할 수 있는 환경이 조성되어야 조직이 경쟁력을 유지할 수 있기 때문입니다.\n\nThis limitation has changed owing, above all, to the introduction of microelectronics in the production process.\n이 한계점은 무엇보다도 생산 공정에 전자공학이 도입됨에 따라 변화했습니다.\nbard)\n전자공학의 도입으로 인해 다음과 같은 변화가 일어났습니다.\n- 다양한 제품을 소량으로 생산할 수 있게 되었습니다.\n- 생산 공정이 더욱 복잡해졌습니다.\n- 조직이 더욱 유연해지고 적응력이 높아져야 했습니다.\n\n예를 들어, 린 프로세스와 애자일 프로세스는은 테일러주의와는 다른 접근 방식을 취합니다. 린 프로세스는 불필요한 활동을 제거하고, 효율성을 높이는 데 중점을 둡니다. 애자일 프로세스는 변화하는 요구에 신속하게 대응할 수 있는 조직을 만드는 데 중점을 둡니다.","조직개념의-한계점#조직개념의 한계점":"Organizational theories at this level of abstraction have found no successor in the present day.\nWhy is this so? They clearly offer obsolete models, models no longer pursued.\n이 수준의 추상성을 가진 조직 이론은 오늘날까지 후계자를 찾지 못했습니다. 왜 그럴까요? 테일러의 조직이론은 분명히 구식 모델을 제공하며, 더 이상 추구되지 않는 모델입니다.\nbard)\n과학적 관리론은 작업 과정을 세분화하고, 가장 효율적인 방법을 찾아냄으로써 생산성을 높이는 데 초점을 맞춘 이론입니다. 이 이론은 노동자를 단순히 기계적인 부품으로 간주하고, 인간의 창의성과 협력을 강조하지 않는다는 점에서 비판을 받아 왔습니다. 또한, 과학적 관리론은 표준화된 제품의 대량 생산에 적합한 이론이지만, 오늘날과 같이 다양한 제품이 출시되고 소비자들의 요구가 빠르게 변화하는 시대에는 적합하지 않다는 지적도 제기되었습니다.\n\n따라서, 과학적 관리론은 다음과 같은 이유로 오늘날까지 후계자를 찾지 못하고 있습니다.\n\n- 인간 중심적이지 않습니다 : 과학적 관리론은 노동자를 단순히 기계적인 부품으로 간주합니다. 이는 노동자들의 동기 부여와 참여를 저해할 수 있습니다.\n- 변화에 적응하기 어렵습니다 : 과학적 관리론은 표준화된 제품의 대량 생산에 적합한 이론입니다. 그러나, 오늘날과 같이 다양한 제품이 출시되고 소비자들의 요구가 빠르게 변화하는 시대에는 적응하기 어렵습니다.\n- 효율성에만 초점을 맞춥니다 : 과학적 관리론은 효율성만을 강조합니다. 이는 창의성, 협력, 학습과 같은 다른 중요한 요소들을 간과할 수 있습니다.\n\n-> 모던타임즈\n\nOn the one hand, faith in the possibility of organizing rationally (in the sense of optimally) on the basis of principle has been lost – both in managerial business theories and in sociological organization research.\n원칙에 근거한 합리적 (최적의 의미에서) 조직화 가능성에 대한 믿음은 경영 비즈니스 이론과 사회학적 조직 연구 모두에서 상실되었습니다.\nOn the other hand, abundant empirical organization research and lively business consulting – efforts that constantly launch new slogans on the market – generate a complexity that can no longer be dealt with by the old forms of theory.\n반면에, 풍부한 경험적 조직 연구와 활발한 비즈니스 컨설팅은 끊임없이 새로운 슬로건을 시장에 출시하는 노력으로 인해 이전의 이론 형태로는 더 이상 다룰 수 없는 복잡성을 생성합니다.\nWhat is more, it no longer suffices, as in older organization theories, to consider only a few types of organization, notably the factory and the public authority.\nSymphony orchestras, newspaper offices, banks, political parties, sport and recreation clubs, schools, hospitals, and prisons also have to be taken into consideration.\n더욱이, 이전의 조직 이론에서와 같이 공장과 공공 기관과 같은 몇 가지 유형의 조직만을 고려하는 것으로는 더 이상 충분하지 않습니다. 교향악단, 신문사, 은행, 정당, 스포츠 및 레크리에이션 클럽, 학교, 병원, 교도소 등 다양한 조직의 특성과 요구를 고려해야 합니다.\nbard)\n과거에 조직 이론은 주로 공장과 공공 기관과 같은 전통적인 조직에 초점을 맞추었습니다. 그러나 오늘날에는 다양한 유형의 조직이 존재합니다. 예를 들어, 비영리 조직, 스타트업, 소셜 미디어 기업 등입니다.\n\n예를 들어, 교향악단은 예술적 창의성을 강조하는 반면, 은행은 안정성과 신뢰성을 강조합니다. 따라서, 교향악단을 위한 조직 이론은 예술적 창의성을 지원하는 데 중점을 두어야 하고, 은행을 위한 조직 이론은 안정성과 신뢰성을 보장하는 데 중점을 두어야 합니다.\n\n이러한 다양한 조직의 특성과 요구를 고려하는 것은 조직 이론의 발전에 중요한 과제입니다. 조직 이론은 다양한 조직이 효율적이고 효과적으로 운영될 수 있도록 돕는 데 중요한 역할을 합니다.\n\nHow is alcoholism therapy organized? Or libraries? Or container transport, which has drastically changed the organization of ports and shipping? Or waste disposal involving the modern functions of sorting and recycling? If this diversity is to be amenable to a general theory of organized social systems at all, the conceptual tools discussed so far will no longer suffice to produce it.\n알코올 중독 치료모임은 어떻게 조직됩니까? 도서관은요? 항구와 선박의 조직을 급격히 변화시킨 컨테이너 운송은요? 분류와 재활용의 현대적인 기능을 포함하는 폐기물 처리는요? 이 다양한 조직들을 지금까지 논의된 일반조직이론으로 적용하기에 충분하지 않을 것입니다.\nThinking in wholes and parts has had its day without being replaced by a theory of complex systems.\nThe question is whether this must remain so, or whether quite different theoretical approaches may allow us nevertheless to elaborate a general theory of organization.\n오늘날 조직에 대해 전체와 부분으로 사고하는 방식은 여전히 복잡한 시스템 이론으로 대체되지 않았습니다. 이러한 사태가 유지되어야 하는지, 아니면 완전히 다른 이론적 접근 방식으로 하여금 조직의 일반 이론을 개발할 수 있는지가 문제입니다.","2#2":"","조직이론-연구의-방향성#조직이론 연구의 방향성":"Since the Second World War, organization research has reached such proportions that no adequate account of trends, results, authors, and publications can be given.\nWe must leave it to the textbooks to report on theory; they often do little else.\nOur approach is to present distinctions that have played a role in research. When a distinction has exhausted its usefulness, it is replaced by another. This occurs when literature uncovers problems or phenomena that had not been sufficiently taken into account and that require a change of frame.\n제2차 세계 대전 이후, 조직 연구는 추세, 결과, 저자, 출판물에 대한 적절한 설명을 제공할 수 없을 정도로 비약적으로 발전했습니다. 우리는 조직 이론에 대한 보고를 교과서에 맡겨야 합니다. (그들은 이 업무를 벗어난 다른일은 거의 하지 않습니다.)\n조직이론에 대해 우리의 접근 방식은 연구에서 중요한 역할을 해온 '구분방식'을 제시하는 것입니다. 어떤 구분방식의 유용성이 소진되면 다른 구분방식으로 대체합니다. 이는 문헌에서 충분히 고려되지 않았던 문제나 현상이 발견되어 프레임의 변화가 필요할 때 발생합니다.\nOur coverage of theory will ignore research that pursues a normative line in quest of rationality, which seeks to establish how certain results can be most effectively achieved with the greatest certainty or at minimal cost, limiting ourselves to approaches that are explicitly or implicitly formulated on the basis of the causality concept.\n본 이론에서는 합리성을 추구하는 규범적 노선을 추구하는 연구, 즉 특정 결과를 가장 확실하게 또는 최소한의 비용으로 가장 효과적으로 달성할 수 있는 방법을 확립하고자 하는 연구는 제외하며, 인과관계 개념을 기반으로 명시적 또는 묵시적으로 공식화된 접근 방식으로 제한합니다.\nOur theoretical and methodological ambition is to coordinate the distinction between cause and effect with other distinctions, for example, that between means and ends or between command and obedience, or between group formation and motivation. In this sense we are concerned with a sociology intent on explanation and, where possible, prediction; or which is also intent on providing technical, advisory aid for organizational planning.\n우리의 이론적, 방법론적 야망은 원인과 결과의 구분을 다른 구분, 예를 들어 수단과 목적, 명령과 복종, 또는 집단 형성과 동기 부여 사이의 구분과 조화시키는 것입니다. 사회학에서는 이를 통해 다양한 조직의 가능한 현상을 예측하며 이를 설명할 뿐만 아니라 조직 계획에 기술적 자문을 지원하는데 관심을 두고 있습니다.\nResearch in business administration or developments in the theory of the firm are also relevant, but their exploitation in sociology has to this day been hampered by barriers between subjects and disciplines, not to mention the sheer volume of the literature.\nThe way is now paved primarily by analysis of relations between structures and decisions. We will be returning to this.\n조직이론은 경영학 연구나 기업 이론의 발전과도 연관성이 있습니다만 사회학에서의 활용은 방대한 문헌은 말할 것도 없고 핵심 주제와 여러 학문  사이의 갭으로 인해 오늘날까지 방해를 받아왔습니다.\n이제 그 길은 주로 조직 구조와 의사 결정 사이의 관계 분석을 통해 열렸습니다. 다시 이 주제로 돌아올 것입니다.","#":"From the older literature, organizational sociology has taken over, above all, the distinction between command and obedience familiar from the sociology of power, as well as the rationality-related distinction between means and ends.\nAuthority can accordingly be rational if it uses commands in such a way that its ends can be attained through obedience. This is not only the old European myth of order, reaching even into theology, but certainly, after the transition from created nature to value relations and the need for legitimation, also Max Weber’s bureaucracy model.\nAccording to Weber, the historical condition for this is that workers lose their ownership of the means of production and are paid in money.\nAs a result, they come under the pressure of imposed work discipline, and the master(whether a holder of political power or the owner of the plant) can rely on the efficacy of his commands. However, such practice in governance and administration is rational only if it can manage without the enormous cost of communicating instructions individually, and can draw up general rules that subordinates can apply to the concrete state of affairs by logical deduction or in typical cases through appropriate interpretation.\nThe model on which this theory draws is legally elaborated public administration.\nBut according to Weber, “bureaucracy” with its formal rationality has imposed itself throughout the world in modern society; for not only political power but also property is a possible basis for power."}},"/idea/math_form":{"title":"Math Form","data":{"":"흔히 학교에서 다루는 중등수학은 크게 대수와 기하로 나눌 수 있다.\n그리고 이 두가지 영역을 합쳐 해석학으로 이어지게 된다.\n이때 대수와 기하는 동일한 대상을 바라보는 관점으로 이해할 수 있다.\n때로는 대수적으로 문제상황을 해결할수도, 때로는 기하적으로 문제상황을 해결할 수도 있다. 이 두가지 시선은 상호보완적으로 작동하는 편이나, 사람에 따라 특정 사고가 더 발달된 경우를 종종 발견할 수 있다.우리의 언어도 이처럼 대수적사고와 기하적사고로 나눌 수 있다.\n유행처럼 번졌던 비주얼씽킹 또한 언어에 대한 기하적 사고라고 볼 수 있는셈이다.\n비주얼싱킹이 단어의 이미지를 그리는데 주목한다면, 개념지도는 개념과 개념간의 구조에 집중하고자 한다.\n이는 다분히 수학적인 접근방식으로, 사고과정을 서술하는 방식이 아닌 도면화 형상화를 진행시키는 방식이다.이때 우리는 기하적으로 그려진 한장의 도표를 통해 수많은 의미를 눌러담을 수 있다.그래서 우리는 언어를 두가지 축으로 바라보고자 한다.하나는 전통적인 서술된 언어\n또 다른 하나는 그들 사이에서 발견되는 구조화된 언어이다.이를 에디터로 제작해보자.그럼 왼쪽 화면은 익숙한 서술방식의 언어가 표현되며\n오른쪽 화면은 기하적 방식의 구조와 이미지가 표현될 수 있다.\n그리고 이 둘 모두를 충분히 연동시킬 수 있을때\n서술형 에디터에서 기하적 모듈을 임배드 하는 방식으로 사용하는게 어떨까 싶다.우리는 흔히 학습하는 과정에서\n학습대상이 되는 텍스트와 시각, 청각 자료를 가져오게 된다.그리고 이를 해석하는 과정에서 새로운 개념의 의미를 깨닫고 관련된 사례를 수집하며 연관개념을 연결하여 학습 대상개념을 더욱 정교하게 만들게 된다.\n하나의 개념은 여러개념들과 맥락상 유기적으로 연결되는데\n이 유기적 정교성, 정합성, 구조성이 결합되며 학문성숙도를 만들어낸다."}},"/idea/predictable_target":{"title":"예측가능한 목표","data":{"":"목표중심 동기이론이 제법 많이 알려져있다.\n하지만 가장 중요한게 빠져있다. 예측가능성.\n목표는 그냥 설정한다고 동기가 되는게 아니라 예측가능한 목표여야 이미 시뮬레이션 된 동작들을 행동으로 자동적으로 수행가능하게 되는것이다.예측가능하지 않은 목표는 목표가 아닌게 아닐까"}},"/idea/thinkable_text":{"title":"Thinkable Text","data":{"":"https://www.youtube.com/watch?v=CaP0C4nAw_Q\n개념없는 직관은 맹목적이고\n직관없는 개념은 공허하다주관과 객관\n물자체와 인식\n실제와 가상, 이미지\n진리생각하기와 말하기\n생각은 무엇으로 구성되는가?\n말하기는 듣는 대상이라는 목적대상이 전제되어있다."}},"/inbox/42seoul":{"title":"'교수❌ 학비❌ 입학하면 오히려 월 100만 원씩 준다는 한국 학교 근황","data":{"":"","교수가-없는-학교에서는-어떻게-공부할까#교수가 없는 학교에서는 어떻게 공부할까?":"https://www.youtube.com/watch?v=0VrB9PoWa04※이 영상은 2023년 5월 17일에 방송된 ＜다큐멘터리K - 대학혁신, 1부. 왜 대학은 달라져야 하는가＞의 일부입니다. 그렇다면 대학혁신이 가야 할 길은 어디인가? 그 해답을 모색하기 위해 세계 최고의 혁신대학이라 불리는 미네르바 대학과 애리조나 주립대학에 혁신의 비결을 물었다…'"}},"/inbox/adorable store":{"title":"Adorable Store","data":{"":"어도러블 스토어는 프론트 개발자이신 테오님이 만든 상태관리 라이브러리다.\n필자는 스벨트에서 기본적으로 제공하는 스토어를 사용하고 있는데 아직까지 큰 아쉬움 없이 사용하고 있긴하다.\n어도러블 스토어는 rxjs에서 아이디어를 가져왔다고 한다.https://github.com/developer-1px/adorablehttps://if.kakao.com/2022/session/81"}},"/inbox/말하는법":{"title":"말하는법","data":{"":"","성공의-척도#성공의 척도":"성공의 척도 = 언변 x 잘 쓸줄 아는능력 x 아이디어의 질이 세가지 요소를 만들기 위해서는\n지식 연습의 양 재능 이 필요\n이중에 삶에 미치는 영향력 또한 지식 > 연습의 양 > 재능 순으로 중요전문 체조선수 메리린튼과 초보스키수업을 들었던 적이 있었다. 그녀는 아무런 지식 없이도, 균형을 잃었을때 다시 밸런스를 잡아내었다. 이건 재능이다. 하지만 여전히 그녀는 초보였고 지식이 없었으고, 내가 지식의 양이 더 많았기 때문에 나는 그녀보다 더 잘해낼 수 있었다.","이야기의-시작#이야기의 시작":"사람을 처음 만날때 농담으로 시작하지 말아야한다.\n처음만난 사람은 이 사람이 어떤 사람인지 탐색을 하고 음역대에 적응하는 시간이 필요\n농담을 던지면 미지근할 수 있다.이야기의 시작은 상대방이 무엇을 얻어갈 수 있는지 이야기하는게 효과적이다\"이 60분의 강의가 끝나면 여러분들은 몰랐던 말하기 지식을 습득할 것이고 지식들 중 몇몇은 여러분의 삶에 지대한 영향을 미칠 것입니다.\"\n-> 완벽한 동기부여","같은-주제를-반복해서-상대방에게-전달하라#같은 주제를 반복해서 상대방에게 전달하라":"4샘플(사이클)한번만 설명해서는 여깄는 사람들의 20퍼센트가 강의 내용을 소화하지 못한채 자리를 뜨게 됩니다. 그래서 네번 반복해서 말할 필요가 있습니다.이야기의 홍수에 빠지지 않게 이야기의 구조를 명확히 해야합니다.\n구조가 명시적일 수록 이야기의 흐름을 놓쳣을때 다시 잘 돌아올 수 있습니다","질문하기#질문하기":"질문하고 7초를 기다립니다. 질문은 너무 쉽거나 어려우면 안됩니다. 너무 쉬우면 쑥스럽고, 너무 어려우면 말할 거리가 없습니다.","강의시간은-언제가-어디서-하는게-적절할까요#강의시간은 언제가 어디서 하는게 적절할까요?":"11시\n피곤해하지 않는 시간.\n불빛이 밝게 비추는 공간\n불빛이 어두워지면 잠을 자라는 신호를 보내는것과 같다.","판서를-하자#판서를 하자":"글씨를 쓰는 속도와 사람이 이해하는 속도가 비슷하기 때문에 판서는 좋은 강연방법이된다.","교구를-사용하자#교구를 사용하자":"내용을 전달할때 이해를 돕기위해 소품을 적극적으로 활용하면 좋다.\n소품을 활용해서 강연을 하면 더 효과적인것은 거울신경세포가 활성화되기 때문, 강연자가 공을 만지면 학습자 또한 간접적으로 공을 만지고 있다.","슬라이드쇼#슬라이드쇼":"글자 도배하지 말고\n자잘한 로고 점 타이틀등 불필요한 모든것을 제거하라\n읽을거리가 많으면 강사의 말을 듣지 않는다\n-> 피실험자는 말을 그만했으면 좋겟다, 방해가 된다고 말했다고 한다.레이저포인터를 사용하면 청중과 아이컨텍을 하기 힘듬\n지시봉도 사용하지 말라.\n포인터를 사용하는대신 화살표를 삽입해서 청중들과 교감을 하는게 중요하다.","가장중요한것#가장중요한것":"청중들에게 이 강의를 통해서 얻어갈 수 잇는것에 대한 기대를 설정하고 영감을 불어넣을 수 있게 설계를 하는게 중요하다영감은 어떻게 불어넣을 수 있는가?\n새내기들은 자신이 할 수 있다고 말을 해주신 고등학교 선생님들에게 영감을 받았고,\n교수님들에게는 문제를 다르게 보게 해 준 시각을 준 사람들에게 영감을 받았다고 합니다.\n모든 사람들에게 공통적으로 영감을 주는 일은, 자신이 하는 일에 열정을 보여줬을 때 영감을 받는다는 사실이다.어떤 면접관이 일자리를 줄 때\n5분안에 본인의 비전과 자신이 뭘 해왔는지 잘 설명할 수 있다면 일자리를 줄 수 있다.\n비전 : 문제점 제시와 접근방법\n해온것 : 본인이 생각하기에 실질적인 솔루션","이야기의-마무리#이야기의 마무리":"농담 좋다\n감사 -> 안좋다\n지루한 강의를 들어줘서 (감사하다)\n는 맥락으로 해석이 가능하다."}},"/inbox/작가와 공동집필":{"title":"작가와 공동집필","data":{"":"주제 : 개똥철학\n내 인생 가치관이 통째로 바뀌었던 경험이 있나요? 어떠한 일로 그렇게 변했는지 상황을 알려주세요.\n내 소중한 사람에게 3가지 이야기를 해줄 수 있다면, 누구에게 무슨 이야기를 하고 싶나요?\n언젠가 이 세상을 떠날 때, 묘비에 어떤 한 마디를 남기고 싶나요?","죽음-앞에선다면#죽음 앞에선다면":"당장 눈앞에 자신의 죽음을 목격한다면 우리는 무엇을 생각할까? 우리는 마지막으로 무엇을 추구할까?우리는 일상적인 삶을 살아가면서 대게 죽음을 예측하지 않는다. 예측가능한 상황들을 늘 염두해 두지만 결코 자신의 죽음을 그날 미리 인지하고 행동을 계획하거나 의미를 추구하지 않는다. 때문에 우리는 자기 자신의 신체가 또 정신이 이전과 같은 방식으로 작동하리라고 믿으며, 삶을 만들어내는 신체의 연장선상에서 자신의 욕망을 인정하고 나 자신의 일부로서 받아들인다.그런데, 죽음을 목전에 둔다면 욕망과 신체를 비롯해 지금 현재 내가 할 수 있는 모든 행동가능성, 예측가능성이 무용지물이 된다. 행동을 상실하면서 나 자신으로서 존재하지 못하게 된다. 나의 기능 자체가 사라지게 된다. 그럼 우리가 생각할 수 있는 유일한것은 내가 어떤 삶을 살아왔고 어떤 의미가 있는지가 아닐까.","망막병증#망막병증":"2020년 초였다. 1월에는 코로나가 발생했다는 뉴스가 조금씩 나타나기 시작했다. 코로나를 기점으로 전세계의 정세가 어지러워지기 시작했다. 양적완화 발표가 나타나기 이전부터 전세계의 주가들은 예상이나 한것처럼 큰 폭으로 떨어지고 있었고, 트럼프 정부에서는 코로나 대비책으로 거의 무제한 양적완화 정책을 내놓기 시작했고, 사람들은 외출을 자제했으며 시장 전체가 두려움으로 가득 찬 시기가 있었다. 그리고 3월 즈음. 하루아침에 왼쪽 시력에 문제가 생기기 시작했다. 왼쪽 눈 중앙부 시력에 문제가 생긴 것이다. 전날 피곤하다는 느낌을 받았고 눈이 침침하다 느끼긴했었는데 자고일어나니 검은 구멍이 뚤려있었다. 눈을 뜨자 마자 당황했고, 시선을 옮기자 그 검은 구멍이 시선을 따라왔다. 구멍의 크기는 1미터 앞 사람의 얼굴을 전부 가리는 정도의 크기였다.병원을 찾아가서 진찰을 받아보니 망막이 혈관장애로 인해 망막에서 벌어진 상황이었고, 얘기를 들어보니 증상이 심하지 않은경우 3개월이면 자연치유가 되는 경우가 많다고 하였다. 병원에서 이 얘기를 듣고 상당히 안심했었지만. 이 병변은 1년이지난 시점에도 좀처럼 잘 회복되지 않았고, 현재 까지 7번도 넘는 재발이 일어났다. 병원에서 말하길 이 질병은 자연치유되는 경우가 흔하게 일어나지만 1년이상 변병이 지속적으로 유지된다면 망막 시신경에 변성이 생겨 영구적으로 시력이 손실되는 경우가 발생하니, 되도록 잠을 많이 자고 스트레스를 피하라는 조언을 들었었다.1년반째 됐을무렵. 좀처럼 나아질 기미가 보이지 않자, 오만가지 생각이 들게 되었는데, 필자는 그 이전까지 교육업에서 10년이상 종사해오던 사람이었다. 수학교육전공으로 아이들을 가르치며 보람을 느끼던 사람이었다. 학교에도 학원에도 교육회사로도 직업을 바꿔가며 일을 해보았지만 역시 가장 만족도가 높은 순간은 학생들을 마주하고 가르칠때가 가장 즐거웠다. 그런데, 이 모든 일을 할 수 있는건 몸이 제 기능을 할 수 있기 때문이다. 눈이 망가지면 내가 이전에 해왔던일을 제대로 수행하지 못하게 된다. 서른 중반의 나이가 되어서도 젊은사람처럼 몸을 혹사해서인지, 한쪽눈이 망가지면서 남은 한쪽눈도 조금씩 좋지않다는 느낌을 받아왔고, 시력을 잃기전처럼 침침한 상태를 여러번 경험하자, 앞으로 시각장애인의 삶을 산다고 생각할수밖에 없게 되었다.하던 일을 모두 때려치우고 회복에 전념하던 나날들이 있었다. 시각을 잃어버릴것만 같은 절망감에 사로잡혀 하루종일 침대에 누워 천정만을 바라보던때가 유난히 기억에 남아있다. 정신은 깨어있지만 이전에 갖고 있던 삶의 연속선상에 있던 모든 가능성을 마음에서 져버려야 했던 그 시간. 일종의 죽지않는 죽음을 경험한게 아닐까. 살아오면서 잘 후회하지 않는 성격인데도 막심하게 후회되는게 하나 있었다. 30년 이상의 삶에서 뭐가 남느냐에 대한 문제였다. 그 시점에서 이전에 내가 누려왔던 행복이나 행복을 만들어주었던 사람들은 전혀 떠오르지 않았다. 사람의 생명은 어느 시점을 기준으로 삶이라는 여정을 경험하게 해줄 몸의 기능을 하나 둘 점차 잃어버리는 과정속에 있다. 인간은 누구나 죽어가고 있다. 그때 가장 후회되는건, 30년 이상의 세월동안 뭘했느냐는 것이었다. 물론 나를 지탱해주던 자신감을 갖게만들어주던 맥락적의미들이 있었다. 내가 속해있는 집단을 기준으로 평범하고 소소하게 행복하다 말할 수 있는것들을 말한다. 나는 그 평범하고 소소한 삶을 충실하게 살아내고자 하였다. 20대 중반부터 해내고 싶은 일이 있었지만, 난 그렇게 비범한 인간이 아니어서 평범하게 회사다니고 소소하게 연애하고 진심을 담은 취미활동 공동체에서 핵심멤버로서 기능 하면서, 그렇게 부대끼고 어울어가면서 살아왔다. 그런데 신체 기능정지의 상황에서 내가 느끼는건, 내가 뭘 해왔냐는 것이었다. 나라고 부르는 모든것이 사라진다면 남아있는것은 아무것도 남지않는다. 책한권 쓰지 않았고, 세상에 영향을 미칠 새로운 지식을 만들어낸것도 아니며, 보다 나은 세상을 위한 기술을 만들어낸것도 아니고, 그저 작은 한점이 찍혔다 사라지는 그런것은 아니었을까. 너무 아깝다.내가 어떻게 될지 모르겠지만 만약 내 인생에 또 한번의 기회가 주어진다면, 글을 쓰고, 이 세상이 필요로 하는 것, 내가 반드시 필요하다고 생각해왔던 것을 남겨 내가 죽어도 작동하게 하는 무언가를 만들어내야겠다고 생각했다. 그 삶이 이전에 살아왔던것처럼 소소하지만 마음이 충만해지지 않는다고 해도 말이다.","산자의-말과-죽은자의-글#산자의 말과 죽은자의 글":"우리 몸에는 여러가지 기관들이 있다. 그 중에 말을 듣는 귀가 있고, 말을 하는 입이 있다. 이 두가지 기능을 욕망을 기반으로 대비시키면 꽤 재밌는 해석이 나온다. 입은 자신의 욕망이 나타나는 기관이며, 귀는 타자의 욕망을 수용하는 기관이다. 실제로 우리가 하는 말의 대부분의 감정적 근간에 욕망이 내제되어있다. 그런면에서 말과 글 모두는 우리 자신의 욕망을 실현시켜주는 중요한 수단이 되기도 한다.욕망을 잘 포장할수록, 말이 정교할수록 타인에게 미치는 영향력이 강해지며 화자의 영향력을 강화시킨다. 특히 글은 말보다 우월한 점이 있다. 말은 화자의 노동력이 매번 요구되는 점이고, 글은 최초의 한번을 제외한다면 더이상 노동력 없이도 반영구적으로 영향력을 재생산할수 있다는 점이다. 그런면에서 산자의 말과 글은 화자의 욕망을 대변해주는 경우가 흔하다. 반면 죽은자의 글은 어떨까? 죽은자의 글에서 죽은자의 욕망은 살아있는 자에게 당사자 대 당사자로서 어떠한 영향력도 없다. 죽은자의 글이 산자에게 영향을 미치는 방법은 욕망을 내비치는 방법이 아니라, 온전히 그들을 위한 정보와 관념을 제공하는것에 있으며 저자의 욕망의 실체인 신체가 없다는 점에서, 독자로 하여금 나에게 필요하고 유용한 정보를 취할 수 있다. 즉, 죽은 자의 글은 욕망보다 애정으로서 기능한다. 심지어는 죽은 저자가 의도한것과 전혀 다르게 대리보충되며 새로운 해석을 사용한다고 말해도 말이다. 그렇기 때문에 저작활동을 때때로 나의 죽음 이후에도 누군가에게 사랑을 전할 수 있는 효과적인 방법이 된다."}},"/":{"title":"hello nextra","data":{"":""}},"/katalk/learn_lang":{"title":"언어를 습득하는 오직 한가지 방법","data":{"":"한줄요약 :\n불안없이 자신감과 흥미를 가지고 이해할 수 있는 인풋을 제공받는 것\n\n\n\n프로그래머들에게도 언어학습의 묘는 동일하게 작용되는것같더라구요. 사실상 대부분의 학습은 언어적 차원에서 이루어지기도 하구요. 새로운 기술문서를 학습하는과정에서도, 새로운 프로그래밍 언어를 배우는 과정에서도 아 이정도면 어느정도 이해한것같은데 싶다가도 막상 내면화가 부족해 영상에서 말한 침묵의 시간속에 있는 자신을 발견하곤 하는데, 조급해할 필요없이 이해 가능한 인풋을 더 찾아봐야겟다 라고 생각하게 됩니다.교육학에서는 행동주의 인지주의 구성주의등의 다른 관점이 있는데, 인지주의적 측면에서 교육자들이 학생의 특성에 맞추려고 이런 저런 다양한 시도를 했으나 정답을 찾아내지못한 선생님들을 위로하는듯 느껴졌습니다. 저도 한때 학생마다 적합한 학습의 방법이 조금씩 다르지 않을까 하는 학습유형론에 빠져있기도 했구요. 열심히 설명해줘도 침묵하는 학생들의 반응에서 좌절할 필요가 없다고. 또 학생 입장에서 나는 수업을 열심히 이해하고 듣는데 왜 아무것도 못하지 라는 좌절감에 불안해할필요가 없다고, 위로해주는것같았네요.사용해보지 않은 기술을 써보려고 작은 사이드프로젝트를 했었는데 이제 막 프로그래밍을 부트캠프를 마친 사람 모였었어요.. 3주간 아무것도 못하고 강의만 듣는것같길래 뭐라도 작성해봐야하지 않겠나 라고 얘기했었는데.. 그것도 침묵의 시간이 아닐까 라고 생각하게 되더군요.제가 생각했을때 침묵의 시간은\n수학으로 치자면 정의를 이해하고 받아들이기, 정의와 예제 연결하기, 정의로부터 정리 연결하기 등의 사고활동들이 떠오르는데, 이런 내재적 연결성이 잘 형성되지 않은 모호한 시간을 말하는것같더라구요. 새로운 기술의 새로운 api를 보고 내부로직은 전혀 모르지만 몇가지 기능이 작동하는것만보고 내부로직을 추론하는 단계의 경우가 비슷한 케이스가 아닐까.. 정신모델이나 개념에 대한 스키마 형성이 잘 되어있지 않은듯 하다.. 라고 생각이 드네요.내부로직이 항상 드러난 수학과 달리 내부로직이 블랙박스처럼 가려진 학습대상들을 잘 이해하기 위해선 다양한 사용사례를 보고 블랙박스 내부를 채워가는 신경망학습과정이 필요한것같고 그 채움의 시간을 침묵의 시간으로 부르는것같다고 생각했습니다.이렇게 첫번째 인지 단계가 잘 해결된다면, 개념에 대한 스키마가 잘형성되고 정신모델이 확립된다면, 비로소 연결가능한 개념들을 더 상세히 인지할 수 있고 잘 연결시킬 수 있는 도구적 사고의 단계, 이해 이후의 적용과 응용 가정 추론 구조화 재구조화 변형 재정의 등 복잡한 단계로 넘어가게된다고 생각해용. 영상에서 말한 유일한방법이라는 강조는 아마 이런 형식적 사고의 단계이전에 정의적이해단계에서 관여하는것들에 한정된것같습니다."}},"/marblewriter_magazin":{"title":"구슬글방 매거진","data":{"":"세컨드브레인 커뮤니티 구슬글방 핵심멤버의 기고문은 여기에서 보실 수 있습니다.월간 구슬글방 매거진"}},"/marblewriter_magazin/expressions":{"title":"'비폭력 대화'와 말. 그럼 표정은?","data":{"":"","몸과-얼굴#몸과 얼굴":"우리는 대게 몸에 대해 기능적 해석을 갖고 있다. 예를들면 눈은 시각정보를 인지하기 위한 인지기관. 손은 무언가를 수행하기 위한 도구적 기관, 다리는 신체의 위치를 변경시키기 위한 기능기관 등으로 말이다.이런 해석에는 대체적으로 전제조건이 깔려있는데, 자신에게 어떤 기능을 수행하는지에 대한 것이다. 그런데 자신에게 어떤 기능을 수행하는가 보다 다른 사람에게 나 자신의 어떤 정보를 전달하기 위한 핵심 기관이 있다면, 그것은 얼굴이라고 볼 수 있다.얼굴은 거의 다른사람에게 보여지기 위해 기능하는 편이다. 특히 시선과 표정 말이 그렇다. 이번에 다룰 이야기는 말과 표정이다.","말과-표정#말과 표정":"다른 사람의 말을 듣고 영향을 받는 일은 종종 발생한다. 특히 다른 사람이 내가 관심있는 대상에 대해 말할 때 더욱 그렇다. 그런데 관심의 대상이 어떤 사람이라면, 우리는 말보다 표정을 더 중요하게 여기고는 한다.말은 소위 말하는 주체 화자의 의지와 사고가 반영되어있다. 그러나, 표정은 사고가 작동하기 이전에 이미 작동되어진다. 표정은 감정의 동요에 따라 즉각적으로 드러난다. 물론 표정도 사람의 성격에 따라 필터링 되어지는 정도의 여부는 각각 다르지만, 근본적으로 감정과 동기화되어있다는 점이 말과 다른점이다.그래서 우리는 말로부터 타인이 생각하는 방향에 대한 정보를 읽을 수 있는 반면, 표정으로부터 그들이 무엇을 느끼는지에 대한 정보를 얻어낼 수 있다.","표정의-발생과-표현#표정의 발생과 표현":"감정은 정보를 인지하는 가치기반 인지체계의 트리거로부터 신체적 반응이 유발되고, 책 회복탄력성의 저자이신 김주환 교수님이 말씀하셨듯이 반응적 신체 상태에 따라 뇌의 편도체를 중심으로 특정기억들이 연결 연상되며 우리 전두엽의 활성화와 상관없이 반응적으로 표정에 나타난다.즉 우리는 상대방의 표정을 통해 어떤 대상을 어떻게 느끼는지 추론할 수 있고, 네이처지에 발표된 연구에 따르면 표정을 16개로 분류할 수 있고 그것은 즐거움, 분노, 경이로움, 집중, 혼란스러움, 경멸, 만족, 욕망, 실망, 의심, 의기양양함, 흥미, 고통, 슬픔, 놀라움, 승리 등이라고 한다. 이 모든 감정을 다시 크게 묶는다면 긍정감정과 부정감정으로 나눌 수 있을것이다. 우리는 상대방의 표정을 통해 어떤 해석 대상이 긍정적인지 부정적으로 느끼는지 추론할 수 있으며 그로인해 상대방이 가진 가치체계 혹은 신념체계까지 깊게 대략적으로 추측 해낼 수 있다.반대로 우리는 자신이 느끼는 정서를 타인을 향해 표정으로 드러낸다. 이는 인식하는 대상에 대해 부정적으로 느끼는지 혹은 긍정적으로 느끼는지에 대한 정보를 적나라하게 제공해줌으로서, 나 자신이 부정적으로 느끼는 대상 혹은 존재가 무엇인지 알리고, 긍정 부정 사이의 가이드라인을 상대방에게 제공하는것과 같다.이 가이드라인, 즉 선을 잘 인지하는 사람들은 소위 눈치가 빠르다고 여겨진다.눈치가 빠른 사람들은 타인을 잘 관찰 할 줄 아는 사람들이다. 그들은 사람이 나타내는 표정을 통해 어떤 정보에 대해 집중하는지 더 깊게는 해당 정보에 대해 긍정적으로 혹은 부정적으로 생각하는지 추론한다.긍정적이라면 해당 대상을 더 공급해주고, 부정적이라면 대상의 공급을 제한하거나 필터링하는 방식을 거치는 것이다. 어느 누가 나를 위해 이런 대처를 해주는데 싫어할 사람이 있을까.하지만 사람이 어찌 타인을 긍정할수만 있을까. 분명 어딘가에 부정할만한 것들이 있을 수 있다.만약 타인이 느끼는 부정적 대상으로 나이거나 나의 일부 혹은 내 의지가 반영된 무엇일때 우리는 어떻게 느낄까?","표현과-관계#표현과 관계":"인간관계에 있어서 때때로 말보다 표정이 더 중요하게 작용할때가 있다.우리는 말할 수 없는것에 대해서 종종 말하곤 하지만, 대체로 표정 지을 수 없는것에 대해서는 표현하지 않는다. 그도 그럴것이 표정은 애초에 잘 통제되지 않는다. 표정은 대상의 인지와 동시에 즉각적으로 반응되어지는것으로, 사고보다 느끼는것에 가까워 느끼는것을 즉각적으로 통제할 수 없는것과 마찬가지다. 우리는 자신이 어떤 표정을 짓고 있는지 모르는 경우도 상당하다.반면 말은 표정에 비해 훨씬 풍부하게 발화자의 인지영역으로 들어온다. 본인이 무슨말을 하는지 (감정을 주체하지 못해 말을 쏟아내는게 아니라면) 명확하게 인지하고 그 말이 뭘 의미하는지 의도까지 전달하기 위해 노력한다. 말을 하는 도중 우리는 종종 상대방의 반응을 살피고 반응에 따라 말을 어떻게 조절할지 결정하기도 한다. 말에 대해 우리는 아주 적극적으로 개입하게 된다.아까 표정이 나타내는 가이드라인을 떠올려보자. 긍정적인 반응의 대상들을 한되 모아 가이드라인을 작성하고 내부를 긍정성의 원이라고 하자.긍정성의 내부에 속하는 모든 존재들을 뭉뚱그려 일컬어 ‘나’의 세계라고 할 수 있지않을까. 긍정의 외부에는 부정의 대상들과 무관심의 대상들로 나눌 수 있고, 이들 사이에는 타인의 긍정성과 부정성이 있을 수 있다.이때 나의 세계에 속하지 않는 부정성들은 나에게 영향력이 없다. 나조차도 부정하거나 무관심하기 때문이다. 하지만 만약 내가 긍정하는 세계에 속하는 대상을 누군가 부정한다면 어떨까? 심지어는 내가 긍정하는 타자가 내가 긍정하는것을 부정할 때 어떨까? 이때부터 우리는 혼란스러운 상황에 빠지게 된다.내가 긍정하더라도 너는 부정할 수 있지. 라며 유연하게 대처하는 사람들도 있고, 보다 맹렬하게 그걸 부정해선 안돼 라며 반응할 수 도 있다.하지만 그 어떤 사람이라도 부정의 대상이 나 자신이거나 나의 일부라면 내면의 갈등에 빠지게 될 수밖에 없다. 논리적으로 모순이 나타나기 때문인데, 내가 긍정한 대상이 나를 부정하는 사건을 마주할 때, 마치 짝사랑의 고달픔처럼 타인을 긍정하고 자신을 부정하게 될 수 있지 않을까. 만약 타자도 긍정하고 나 자신도 긍정하려면 긍정과 부정 사이의 골을 소통으로 채워내야만 할것이다.이런 부정성에 특히나 말보다 표정이 앞선 부정성이었다면, 이 표정의 근원이 가치관의 문제 세계관의 문제에서 비롯된 가치판단의 정서라면, 시간과 공을 들여 소통을 통해 개선하기 쉽지 않을것이다. 해당하는 부정성이 뿌리깊은 느낌의 영역, 서로 병합되지 않는 가치관의 영역에 있다면 조절도 힘들뿐만 아니라, 각자가 살아온 세월만큼이나 변하기 어렵고, 우리는 종종 관계 자체를 재정의 하고는 한다.말의 공격성은 폭력적일 수 있지만 표정의 공격성은 파괴적 일 수 있는게 아닐까.비폭력 대화는 느낌의 뿌리깊은 영역에서 나타난 균열을 매워 낼 수 있을까?","chatgpt#chatgpt":"말은 조절가능한것같은데 표정은 조절하기가 힘든것같아. 왜그런걸까??\n\n말과 표정의 조절능력 차이는 말과 표정이 서로 다른 뇌 회로를 사용하고, 생물학적 유산과 사회적 경험의 영향을 받기 때문입니다.\n\n1. 다른 뇌 회로의 사용: 말은 주로 언어 및 운동 기능 관련 지역(예: 브로카 영역)을 사용합니다. 이 과정에서 발화, 단어 선택, 문법 등의 조절이 가능합니다. 반면, 표정은 애초에 감정의 자연스러운 반영으로 시작되며, 무의식적으로 생성되기도 합니다. 여러 뇌 영역 중 안면 운동 피질이 안면 근육의 움직임에 관여하지만, 이들의 조절은 의도적이지 않은 경우 힘들 수 있습니다.\n\n2. 생물학적 유산: 말은 사회적 소통 도구로 자연 선택 과정에서 인간의 고유한 능력으로 발전했습니다. 따라서 말의 의도적인 조절이 인간의 기본 능력 중 하나입니다. 반면, 표정은 진화 과정에서 다양한 종에서 발견되며, 자동적이고 감정의 직접적인 반응입니다.\n\n3. 사회적 경험: 사회적 교육과 경험을 통해 언어 습득 및 의사소통 방법에 깊이 관여합니다. 반면에 표정은 어려운 상황에서 본능적으로 반응할 수 있는 능력을 향상시키는 데 더 집중되어 있는 태생적 기능입니다.\n\n\n그러나 표정을 조절하기 어렵다고 해도, 이를 일부 조절하는 능력이 없는 것은 아닙니다. 어떤 사람들은 전문적인 연기 훈련이나 일상 경험을 통해 표정을 의도적으로 제어하는 법을 배울 수 있습니다. 또한 적절한 시기와 상황에 맞게 표정을 조절하는 것은 사회적 기술의 중요한 부분이기도 합니다. 하지만 전반적으로 표정 조절은 말의 조절보다 어렵다고 할 수 있습니다.\n\n정보를 인지하고 표정이 나타나기까지의 작동원리에 대해서 순차적으로 설명해줄래?\n\n사람이 정보를 인지하고 표정이 나타나기까지의 작동 원리를 순차적으로 살펴보겠습니다:\n\n1. 감각 입력: 눈, 귀, 코, 입, 피부와 같은 감각기관에서 외부 환경의 정보가 수집됩니다. 이 정보는 무언가를 보거나, 듣거나, 맛보거나, 만지거나, 냄새 맡는 등 다양한 방식으로 입수될 수 있습니다.\n\n2. 정보 처리: 감각기관을 통해 입력된 정보는 중추신경계로 전달되어 처리됩니다. 이 과정에서 적절한 뇌 영역에 정보가 전달되고, 두뇌가 이 정보를 해석하여 인지되는 정보로 변환됩니다.\n\n3. 감정 생성: 정보 처리 과정에서 얻어진 인지된 정보는 개인의 경험과 상황에 따라 연관된 감정과 연결될수 있습니다. 표정에 반영되는 감정은 발생하기도 하며 이미 존재하는 감정 변화에 영향을 줄수 있습니다.\n\n4. 전두엽에서의 감정 조절: 뇌에서 감정이 생성되면 전두엽-특히 벤트랄메디알 프리프론탈 코텍스(ventromedial prefrontal cortex) 등의 영역이 감정과 관련된 반응을 조절하는 역할을 담당합니다.\n\n5. 안면 근육 활성화: 감정 조절 과정에서 뇌는 감정에 상응하는 표정을 만들기 위해 안면 근육을 활성화합니다. 이 과정에서 안면 운동 피질(facial motor cortex) 영역이 뇌에서 발신되는 신호를 안면 근육에 전달합니다.\n\n6. 표정 생성: 활성화된 안면 근육은 특정 패턴으로 움직입니다. 이러한 움직임이 조화를 이루면 감정을 나타내는 표정이 생성됩니다.\n\n\n이러한 과정을 통해 주변 환경에서 정보가 인지되어 처리되고, 감정이 발생하고 조절되며, 마침내 표정이 생성됩니다. 표정은 감정을 표현하는 동시에 다른 사람들과 소통하는 매우 중요한 방법입니다. 여러 상황에서 다양한 원리의 실행과 조절은 개인의 경험, 성격, 문화적 배경 등에 따라 결과가 달라질 수 있습니다.\n\n그럼 이번엔 정보를 인지하고 말을 하기까지의 작동원리에 대해 순차적으로 설명해줘\n\n사람이 정보를 인지하고 말을 하기까지의 작동 원리를 순차적으로 살펴보겠습니다:\n\n1. 감각 입력: 눈, 귀, 코, 입, 피부와 같은 감각기관에서 외부 환경의 정보가 수집됩니다. 이 정보는 무언가를 보거나, 듣거나, 맛보거나, 만지거나, 냄새 맡는 등 다양한 방식으로 입수될 수 있습니다.\n\n2. 정보 처리: 감각기관을 통해 입력된 정보는 중추신경계로 전달되어 처리됩니다. 이 과정에서 적절한 뇌 영역에 정보가 전달되고, 인지된 정보로 변환됩니다.\n\n3. 언어 생성: 인지된 정보를 바탕으로 주어진 상황과 맥락에 따른 말의 내용이 생성됩니다. 이 과정에서 워니케 영역(Wernicke's area)이 어휘와 문법을 통한 언어의 의미 생성을 돕습니다.\n\n4. 말하기 계획: 브로카 영역(Broca's area)가 언어를 구성하는 방식을 계획합니다. 이 영역은 말의 구조를 결정하고, 문장 구조와 발화를 조절하는 데 관여합니다.\n\n5. 운동 피질 활성화: 브로카 영역에서 생성된 말의 정보가 신호로 변환되어 기본 운동 피질(primary motor cortex)로 전달됩니다. 이 영역은 말을 하기 위해 구강 근육(입, 입술, 혀, 상악)을 움직이는 데 필요한 운동 신호를 생성합니다.\n\n6. 발화: 생성된 운동 신호들은 구강 근육에 전달되어 음성기관(폐, 성대, 인두, 구강, 코강)이 음을 생성하고, 말 소리가 완성됩니다.\n\n\n이러한 과정을 통해 사람은 정보를 인지하고 처리한 후, 언어 생성 및 발화를 통해 말을 할 수 있습니다. 상황, 개인 경험, 성격, 문화적 배경 등에 따라 이러한 과정에도 변화가 있을 수 있습니다."}},"/marblewriter_magazin/search_path_for_concept_map":{"title":"영감과 대화, 경로탐색","data":{"":"","영감의-개념#영감의 개념":"우리는 각자가 학습한 대로의 개념을 갖고 있다. 여기서 개념이란 실제적이거나 추상적 관념의 한 단위로, 그 자체로 추상적이나, 어떤 다른 개념, 관념, 경험 연결될 때, 그 쓰임새를 보여주게 된다. 즉, 개념은 독립적이고 단독적으로 존재한다기보다 무언가와 연결되는 분기점의 역할을 하기도 한다.영감이란 개념 자체도 사용되는 맥락에 따라 해석이 달리 되게 마련이다. 영감이란 표현은 대게 종교나 예술에서 많이 사용되는데, 종교에서는 신이 내려준 지혜나 생각을 뜻하고, 예술에서는 창조적인 일의 계기가 되는 빼어난 착상이나 자극을 말한다. 그리고 우리는 대화하면서 영감을 얻는다는 표현을 종종 하게 된다.영감은 학습된 개념이 가진 연결경로 이외의 새로운 경로(한 개념의 새로운 시각 혹은 사용 방법)를 발견하게 되는 순간이거나, 혹은 기존의 연결경로를 수정하는 경우, 혹은 개념 자체의 정의를 수정하는 경우 등을 예로 들 수 있다. 이러한 변화를 총체적으로 다시 보면 영감은 결국, 인지된 개념이 변화되는 과정과 매우 연관이 깊다는 것을 알 수 있다. 개념변화의 과정은 학습 과정 그 자체를 의미한다.즉 영감은 학습의 본질 위에서 작동한다는 것을 알 수 있다.영감이 대화하면서 많이 발생하는 이유도 교수학습의 원리와 같다. 타인의 말을 집중해서 듣는 행위, 몰입해서 이해하는 과정을 통해, 타인이 사용하는 개념이 어떤 상황 어떤 맥락에서 무엇과 어떻게 연결 적용되는지를 이해하는 과정에서 내가 이전에 미처 학습하지 못한 사용성이나 시각을 깨닫고 이해하게 되고, 이를 통해 영감을 얻어 새로운 활동이 유발된다. 이 새로운 활동을 통해 기존의 개념에 새로운 시각과 연결되기도 하며, 기존의 연결 과정을 뒤엎어 내기도 한다. 이 과정 교육의 본질과 맞닿아 있다. 그래서, 교육의 상당 부분은 대화로 구성돼 왔다.학습의 관점에서 책이 더 많은 영감을 줄 수 있겠지만, 대부분 사람은 대화하면서 영감을 얻는다고 한다. 이유는 간단하다, 책은 나를 이해하고 피드백을 줄 수 없지만, 사람은 어느 정도 가능하기 때문이다. 그래서 책이 더 위대한 영감을 줄 수 있을지언정 독자를 고려해서 정보를 제공하지 않기 때문에 우리는 많은 영감을 대화에서 얻어낸다.그럼, 대화와도 같이 사람들에게 영감을 제공할 수 있는 수단은 없을까? 책처럼 모든 걸 다 읽어야만 이게 똥인지 된장인지 구별할 수 있지 않고, 사람처럼 나에게 필요한 영감을, 개념적 학습 가능 지점을 찾아낼 방법은 없을까?","택시와-네비게이션#택시와 네비게이션":"내비게이션이 없던 시절에는 택시 기사의 지식은 그 자체로 엄청난 가치가 있었다. 지금에야 택시의 지식보다 내비게이션을 더 믿는 시대가 되었지만, 내비게이션이 없던 시절, 지도과 위치에 관한 지식은 사회적으로 늘 높은 가치를 인정받아 왔다.더 이전의 시대로 거슬러 올라간다면, 지도가 없던 시대와 지도가 있는 시대로 나눠 생각해 볼 수 있는데, 지도가 없던 시대에는 유경험자의 지리적 정보의 가치가 매우 높은 평가를 받았다.\n상인들은 늘 사람들과 대화하며 어디에 어떤 물건이 있는지 어디에 어떤 물건이 필요한지 경험하여 학습하고 그 정보가 정확할수록 더 큰 부를 얻을 수 있게 되었다.\n그뿐만 아니라, 지리적 정보는 군사전략의 가장 핵심이 되는 정보다. 전쟁에 앞서 고지대를 미리 선점해 낸다면, 강한 이점을 가질 수밖에 없는 게, 각종 투사체의 사거리가 길어질 뿐만 아니라 전투 시 체력적으로도 우위를 점할 수 있었다.현대에 이르러 이런 지리적 정보를 데이터베이스에 넣고, 원하는 위치에 도달하는 최단 경로를 산출해 주거나, 최소시간경로를 추천받을 수 있게 되었다.하지만, 우리 교육은 아직도 전통 방식 그대로를 벗어나지 못하고 있다.교육은 개념이 변화되어 가는 과정이고, 개념은 연결가능한 경로의 한 분기점으로 추상화시킬 수 있다면, 개념에 대한 지도도 충분히 만들어 낼 수 있을 뿐만 아니라, 내비게이션도 만들어 낼 수 있다.비약이 있는데 비약을 채워보자. 개념이 왜 분기점이란 말일까?","개념과-문제해결#개념과 문제해결":"앞서 언급했듯 개념과 문제해결은 미로에서 길 찾기와 굉장히 연관이 깊다. 애초에 개념을 사고하는 뇌의 뉴런 연결구조 자체가 아주 복잡한 미로처럼 구성돼 있기 때문이다.우리가 무언가에 대해 생각하게 되면 생각의 경로를 따라가다 개념적 분기점에 이르게 되고, 분기점에서 한 경로를 선택하여 개념의 이어서 생각하곤 하는데 이 과정은 뉴런이 정보를 처리하는 과정과 일치한다. 뉴런은 자극받은 전기적 신호를 연결된 뉴런 중 특정 경로에 선택적으로 전기적 신호를 보낼 수 있고, 이때 활성화된 경로의 뉴런이 해당 경로와 연결된 회로를 가동하면서 집중의 요소를 한 방향으로 제한시킨다.우리 뇌는 무엇에 대해 생각하면서 끊임없이 분기점 사이에서 길 찾기를 하는 것과 같다. 그리고 문제해결을 잘 해내려면 개념이 가진 연결경로가 모두 학습되어 있을수록 유리하다.하나의 문제상황은 문제해결에 앞서 여러 가지 해답이 있을 수 있지만 아무 데나 가도 늘 문제를 맞힐수 있는 것은 아니다. 특정 방법들 안에서만 문제가 해결되는 경로가 존재하고, 그 경로의 분기점에는 이 개념을 어떻게 활용해야 할지, 어떤 방식으로 바라봐야 할지, 어떻게 활용해야 할지, 개념 사용의 경로를 선택해야만 한다.그래서 문제해결의 가장 중요한 점은 개념이 가진 경로의 전체적 특성을 얼마나 잘 이해하고 있는가, 이 시도가 먹히지 않는다면 어떤 시도를 할 수 있을 것인가? 라는 물음들의 연속과도 같다. 만약 개념학습이 잘 되어있지 않다면, 개념 연결성에 제한이 생기고 이 제한이 생긴 경로를 사용해야만 풀리는 문제에서 늘 막다른 골목에서 서성이게 될 수밖에 없는 것이다.이를 해결하기 위해 선인들은 그리고 성공한 사람들은 늘 책을 보라고 말하지만, 지식의 적합성이 늘 잘 맞는 것은 아니고 그러다 보니 당장 필요한 몇 가지 개념을 얻어내기 위해 해당 분야의 전문서적 10권 이상의 책을 학습해야만 한다.마치 내비게이션이 없던 시절에 전혀 모르는 곳에 도달하려고, 이 사람 저 사람 물어물어 열 사람 이상의 전문가에게 물어 정보를 취합해서 모험을 떠나는 것과 같다. 이게 작금 교육의 형태다. 전문가에게 물을 수 있으면 다행이나, 거의 무한대로 쏟아져 나오고 있는 수많은 강의들 사이를 여전히 떠돌아야만 한다.컨텐츠가 엔트로피의 법칙을 순리대로 따르며 무한히 증식하고 있는데, 우리 똑똑한 내비게이션은 증식하지 않는다. 그 비결은 정확한 데이터와 정확한 연산 처리에 있다. 미로 문제 풀이 알고리즘에 솔루션에 대한 힌트가 들어있는데, 핵심은 하이라키구조가 가지고 있다.","미로와-트리구조-경로탐색#미로와 트리구조 경로탐색":"위와 같은 미로가 있다고 해보자. 전체 그림을 보면 풀기 어렵지 않겠지만, 미로 안에 갇혀서 전체모습을 볼 수 없다면, 미로가 더욱 복잡해진다면 출구를 찾기 쉽지 않을 수 있다.문제해결에는 정해진 경로를 걸어나가는 능력과 분기점에서 선택할 수 있는 모든 경로를 인지하는 능력, 그리고 잘못된 경로로 들어섰을 때, 이전에 선택했던 경로가 무엇이었는지 기억하는 능력이 필요하다.이때 경로선택의 분기점을 개념이 필요한 상황이라고 볼 수 있었는데, 그림으로 표시하면 다음과 같다.\n\n빨간 블럭에서 파란 블럭으로 나아가고자 할 때 분기점을 모두 표시하면 그림의 녹색 블럭과 같다. 각 분기점은 경로를 선택해야 하며, 이때 분기점이 개념을 마주했을 때, 이 개념을 어떤 방식으로 연결시킬지 선택하는 과정이라고 볼 수 있다.만약 개념에 대한 학습이 덜 되어있어서 1번 분기점에서 아래로 가는 경로가 학습되어 있지 않다면 이 미로에서의 문제해결은 시작부터 어려움에 봉착하게 되는 것이다.\n\n\n뿐만 아니라 보통 문제상황은 중간 과정이 좀처럼 보이지 않는 경우가 많다.\n\n\n하지만 수많은 개념은 이미 대중에게 열려있고 정보의 바다 위에 떠돌아다니고 있다. 문제는 그 개념들이 잘 구조화되어 있지 않다는 것이다.인터넷에는 수많은 정보가 있지만 상당수가 구조화된 정보가 아니다 보니, 방대하게 복제되고 무분별하게 쏟아져나오고 있다. 현재 언어 학습 인공지능은 이런 문서들을 사람이 정제해서 가공된 데이터를 학습시키고 있지만 여전히 계층화된 정보는 아니라는 점에서 한계점이 있다.위의 미로처럼 명료하게 계층화시킬 수 있다면 보다 똑똑한 인공지능이 나오는 것은 자명하다.\n\n\n이 그림의 미로가 왜 계층화되어 있다는 걸까?\n각 분기점에서 이어지는 경로를 표시하면 위 그림과 같은데 이를 하이라키로 변환하면 다음과 같다.\n\n\n이런 문제상황에 있어서, '길을 찾는다', '방법을 찾는다', '영감을 얻는다'는 말은 위 계층구조의 각 분기점에서 어떤 방향으로 나아갈지 학습한다는 개념임과 동시에 새로운 시각을 얻는다는 말과 동일하다. 기존에 학습되지 않았던 지식에 새로운 문제해결의 출구가 열린다면 동기가 되지 않을 수 없다.컴퓨터 알고리즘은 이런 경로 탐색에 아주 효율적인 연산이 가능하다. 물론 모든 경로가 학습되어 있다는 전제조건 하에서 가능하다. 특히 하이라키 구조는 지식이 방대해져도 그 양이 점차 수렴되어 가는 양질의 정보 계층이기 때문에 연결성의 논리적 힘이 아주 강력하다고 볼 수 있다. 수학 문제를 해결할 때도 이 하이라키 경로 탐색과 정은 우리 머리속에서 그대로 나타나게 된다. 사실상 이 탐색 알고리즘 자체가 인간의 사고를 모방해서 만들었기 때문이다.위 문제는 중3 수학인데, 고등수학의 등비수열을 이용해서 문제를 풀어도 되지만 중2 기하학의 비례식을 이용해서 문제를 풀 수 있는데 풀이 과정은 다음과 같다.주어진 식으로부터  ,  로부터 다음 항이 될 때 1/3배씩 곱해진다는 패턴을 찾아내고,닮은 도형의 넓이의 비는 길이에 비의 제곱과 같다는 닮음 개념의 한 경로를 떠올려 닮음비를 찾아내고 과 정삼각형의 넓이 으로부터 한 변의 길이를 구하는 방정식 개념을 떠올려나온 결과물들을 연립방정식으로 연산하면 정답을 구할 수 있다.풀이에서와 같이 수학에서 문제해결은 각 개념의 활용을 선택하는 사전지식에 의해 문제해결에 대한 경로를 찾아내는 것과 같다. 또 수학은 엄밀하게 정돈된 하이라키 구조로 되어 있기 때문에 하나의 개념에 대해 모든 경로를 탐색했다면 더 이상 해당 영역에 대해 고민할 여지 자체가 없어지는 것이다.로지컬 싱킹, 박문호 박사님의 집합론적 사고, 직장인들이 배우는 MECE한 사고방식까지 모두 이 트리 구조적 사고방식을 논리의 베이스에 가져가고 있다.하지만 세상엔 트리 구조로 표현되지 않는 정보가 무수히 많다. 그럴 땐 어떻게 할까?","비선형-비-계층-구조-그래프-구조에서의-경로-탐색#비선형 비 계층 구조, 그래프 구조에서의 경로 탐색":"미로를 조금 더 변형시키면 아래와 같은 상황이 더 복잡하게 연결될 수 있게 되기도 한다.\n\n이 미로의 경우 계층구조로 회귀하지 않는 그래프구조를 띄고 있는데, 1번 분기점과 8번 분기점이 연결됨으로서 위 1번과 8번 중 어느 분기점이 상위구조인지 명확하지 않은 경우가 발생한다. 어떤 문제를 풀다 보니 다시 처음 상황으로 되돌아오는 경우를 말한다. 이런 아일랜드형 경로가 두세 개만 얽혀있더라도 자칫 잘못하면 길을 잃어버리기 십상이다. 이런 상황에서는 문제를 해결해 나가려면 목적지의 방향으로 경로를 우선 선택하되 지나간 경로는 길목에 표시해서 찾아나가야만 한다. 헨젤과 그레텔이 집에 돌아가기 위해 마크해 둔 것처럼.이런 상황은 컴퓨터가 더욱 전적으로 유리할 수밖에 없는데, 단시간에 모든 경로를 계산해서 최단 거리를 찾아낼 수 있기 때문이다. 심지어는 모든 경로를 탐색하지 않고도 최단 경로를 찾아내어 내비게이션처럼 길을 제공할 수 있다. 우리가 흔히 게임에서 목적지를 클릭하면 자동으로 경로 검색하는 알고리즘이 거의 실시간으로 연산 되어 즉각적으로 반응하는 모습을 볼 수 있기도 하다.하이라키가 논리적인 힘을 만들어 준다면, 하이라키가 아닌 비선형구조의 경로 탐색 기능은, 시각정보(내비게이션)를 제공하고 효율성(최단 거리)을 제공한다.학습에서 이런 서비스는 전문 선생님의 과외 말고는 방법이 없다. 즉 과외선생님이 해주는 교육 서비스는 지식에서의 경로 탐색 알고리즘에 가깝다는 말이다.","차세대-인공지능-교육-서비스#차세대 인공지능 교육 서비스":"현재 인공지능은 문자 단위로 구축되어 서비스되고 있다. 인터넷에 있는 글자들의 연관정보를 입력시켜 학습해 그래프 구조에서 나름의 내비게이션 역할을 문자 단위에서 해주는 서비스이다. 하지만, 문자 단위가 아니라 사고의 기본단위는 개념이기 때문에 개념의 연결이 카테고리 없이 연결되어 학습된 수준에서 언어모델이 아니라, 개념과 개념들이 어떻게 연결되어 있는지 충분히 잘 모델링된 데이터를 토대로, 생각의 경로를 온전히 제공해 주는 서비스가 나올 수 있을 것으로 기대한다.그렇게 하기 위해서는 보다 진보된 집단지성이 구축되어 있어야 하며, 현재의 위키백과를 뛰어넘는 더 양질의 집단지성의 장이 필요하다. 그리고 그 장에서는 하이라키와 그래프 연결이 구분되어 있어야 한다. 논리의 장 하이라키영역에서는 지식들이 끊임없이 수렴되어 최첨단의 지식과 연결되어 있으면서 동시에 생성의 장 그래프영역에서는 개인의 사소한 생각도 연결되며 확산되어야한다. 그러한 엄밀하면서 또 어설프거나 신선한 연결들의 총체는 우리를 더 나은 교육혁신의 현장으로 이끌 것이다. 굳이 인공지능이 아니라, 그냥 경로 탐색 알고리즘만으로도 말이다."}},"/marblewriter_magazin/the_wailing":{"title":"곡성(미완...)","data":{"":"곡성은 2016년에 개봉한 공포영화입니다. 그 당시 이 영화를 보고 찜찜한 기분에 영화를 다시 관람하고 글을 썼던 기억이 납니다.곡성은 공포영화입니다. 이 영화에 대해 두번째 리뷰를 쓰면서 그때는 없던 뇌과학 지식들이 오버랩 되면서 공포라는 감정 입장에서 해석해보려고 했습니다.","공포에-대해#공포에 대해":"먼저 두려움과 공포는 어떤 감정일까요? 분명 한여름에 더위를 조금이나마 해소할 수 있게 오싹한 기분이 들게하는 공포감정은 사람들을 충분히 얼어붙게 만드는 힘이 있습니다.뇌과학에서 뇌는 감정 없이 태어난다고 합니다. 뇌는 예측하는 기계로 태어나며 정신적 신체적 사건에 대해 예측하는 기계라고 합니다. 우리의 신체가 인지적 자극을 받을때도 이 현상의 원인에 대해 예측하게 됩니다. 여기서 예측불가능성이 공포와 연결이 됩니다. 쉽게 말해 우리가 시각이 잘 작동하지 않는 장소에 서 있을 때 갑자기 큰 소리가 발생하게 되면, 큰소리의 원인이 무엇인지 예측하게 되고, 예측되어진 바에 따라 내 신체에 대한 안전여부가 인지되지 못할 때 우리 신체는 공포받응을 얻게 된다고 하죠. 이때 우리 뇌는 큰 소리에 대한 신체 내부의 반응 또한 예측하게 된다고 합니다. 신체를 보호하기 위해 심박수를 높이고 혈액 공급속도를 증가시켜 보다 빠르게 반응하도록 신체상태를 만들어냅니다. 이때 몸의 상태를 인지하는데는 세부적인 모든 사항에 대해 인지하기는 힘들지만, 쾌감, 불쾌감, 활성화, 비활성화는 구분해낼 수는 있다고 합니다. 이 평형상태가 깨어질 때 우리는 감정이 움직인다고 느끼게 됩니다.신체감각의 촉발은 사고를 일으키고, 외부자극에 대한 사고는 신체반응을 일으키게 됩니다. 여기서 공포반응은 외부자극에 대한 해석이 신체반응에 악영향을 미치고, 이 신체반응에 대한 사유가 촉발되어 위험상황들을 상상하고 이로인해 다시 신체반응이 악화되는 루프에 빠지게 되는것을 공포스럽다라고 얘기할 수 있습니다.여기서 공포의 특성중 하나를 엿볼 수 있습니다. 공포 상황은 감각정보가 매우 부족하거나 예측하기 어렵다는 점입니다. 예를 들어 우리가 막 복싱을 배운다고 가정해봅시다. 이제 막 복싱을 시작했지만 어느것도 학습되어있지 않은 상황에서 경력자와 스파링이 시작된다면 도저히 예측이 작동하지 않습니다. 이 상황에 대해 익숙하지도 않고 전혀 학습되어있지 않기 때문에 어떤 동작도 제대로 예측해낼 수 가 없는거죠. 그때 공포상황을 회피할 유일한 수단은 공격 거리를 내어주지 않는것입니다. 공격 가능한 사거리 안에 들어가면 언제 어떤방식으로 맞게 될지 전혀 알수가 없으니까요. 하지만 우리가 10여년간 복싱을 수련했다고 한다면, 적어도 나와 비슷한 수준의 사람과 마주하여 스파링을 할 때, 내가 가능한 공격과 불가능한 공격 동선들을 이해하고 있으며, 상대방이 어떤 움직임이나 모션을 취할때 어디가 위험한지 늘 감각을 동반하여 예측할 수 있게 됩니다. 공격당할것이라는 예측가능성 너머의 빈틈을 만들어내어 상대방을 향해 공격해내는 수많은 경험을 통해 복싱에 대해 두려움을 느끼지 않게 됩니다.그래서 늘 공포영화는 시청자가 경험했던것으로부터 경험하지 못한 미지를 가져와야만 합니다. 미지에 걸친 감각의 부재와 예측의 과잉이 공포를 만들어내기 때문입니다. 그래서 공포영화의 상당수가 비현실적인 판타지를 동반하기도 합니다.예측 불가능성은 그 자체로 종종 현실을 왜곡하여 인지하게끔 하기도 합니다. 당사자가 느끼는 바는 어떨까요? 현실과 왜곡된 현실을 잘 구분할 수 있을까요? 이미 왜곡되어진 순간부터 좀처럼 구분하기 어려워질 수도 있지 않을까요?철학사에서도 인식론에 관한 다양한 논쟁이 있어왔습니다. 우리가 인지한 세계는 세계 자체가 아니라 우리가 인식한 단편, 가상에 불과하다라는 입장이 그것입니다. 영화 매트릭스에 잘 반여되어있죠. 파란약과 빨간약으로 만들어진 가상에서 살아갈지, 실제 세계로 뛰어넘어갈지. 감정 자체가 뇌가 태생적으로 갖고 있던게 아니다보니, 감정은 문화권마다 전혀 다르게 나타나기도 합니다. 한 문화권 내에서 공유된 감정들을 학습함으로서 우리에게 감정은 실제처럼 와닿게 됩니다. 실제로 에스키모인들은 분노가 부재하고, 태평양 타이티섬의 사람들에게 슬픔이 부재하다고 합니다. 감정은 말과 표현 개념과 의미로 연결되고, 의미가 부재할때 감정은 자라날 겨를이 없다는거죠.감각하기 힘든데 공포상황이 예측될때, 그리고 그 경험이 반복될 때, 공포감정은 점점 커지고 실재가 됩니다. 공포의 의미는 어디서 출발할까요? 확신할 수 없는 미지의 감각을 예측할 때, 의심할 때, 의심의 실체를 마주하고 이 의심을 공유받으며, 집단적으로 실체화 될 때, 그것이 가상이든 현실이든 실재화 되는게 아닐까요? 이 영화 곡성에서도 공포와 의심 집단적 확신이 한되 어울어져 관객까지도 의심의 실재 악마와 마주하게 됩니다.","영화#영화":"이 영화 곡성에서도 현실과 비현실을 넘나들면서 공포의 본질에 대해 접근하고 있다고 생각했습니다.이 영화에서는 여러가지 사건들이 나열되고 등장되지만 어느 사건 하나조차 논리적 연결성이 명확하지 않은 모호함속에서 이야기가 전개되어집니다. 그 빈틈에서 관객의 마음속에 파문을 일으키며 공포를 유발하게 됩니다.이 영화는 좀비와 질병 귀신 종교등을 넘나들면서 우리가 아는 현실을 비현실과 연결시킵니다. 그리고 영화의 종반부까지 와서도 각 사건들의 인과관계에 관한 정보를 제공하지 않고 끝끝내 미궁속에 빠뜨리게 됩니다. 그리고, 감독이 만들어낸 새로운 공포를 자극하여 관객들의 의심해오던 바를 실체화하여 남아있게 만들어냅니다.영화에 대해 7년이 지난 지금은 더이상 회자되지도 않고 나름대로 대중의 호응을 받은 해석도 존재하고 있습니다. 가장 인기있던 해석은 독버섯 해석이었죠. 영화에서는 불가사의한 사람들에 죽음에 대해 그 원인이 무엇인지, 명확한 결론을 제시하지 않고 끝맺음 지었습니다. 저는 몇가지 키워드를 중심적으로 해석해봤습니다.영화의 이런 문구로 시작합니다.\n그들은 놀라고 무서움에 사로잡혀서\n유령을 보고 있는 줄로 생각하였다.\n예수께서는 그들에게 말씀하셨다.\n\"어찌하여 너희는 당황하느냐?\n어찌하여 마음에 의심을 품느냐?\n내 손과 내 발을 보아라\n바로 나다\n나를 만져 보아라.\n너희가 보다시피,\n나는 살과 뼈가 있다.\"그리고 중간에 신부님이 이런 대사를 보여줍니다.그 사람들 시각으로 보자면 귀신은 죽은 사람의 영혼 아니오?\n근데 그 사람은 살았잔소\n지도 몇번을 그 사람에 관한 소문을 들었는디\n유명한 대학교수란 소리도 있고\n무시무시한 소문들도 있소\n스님이란 소문도 있소\n그런디 그냥 그것은 소문 아니오 소문\n어찌 그걸 믿고신부님 아닙니다 절대 아닙니다계속 확신을 하시네요 직접 보셧소? 직접 보도 않고 어떻게 확신을 하십니까?\n병원에 돌아가서 의사를 믿고 하느님께 맏기세요\n교회에서 해드릴 얘기는 없습니다.","1-주요-등장인물#1. 주요 등장인물":"종구(곽도언)\n효진(종구딸)\n종구 부인\n종구 장모일광(황정민)\n외지인(쿠니무라준)\n무명(천우희)\n양이삼(부제)\n동료경찰(양이삼 삼촌)\n...","2-줄거리#2. 줄거리":"영화는 다음 문구로 시작합니다.곡성은","2-공포란-무엇인가#2. 공포란 무엇인가?":"","#":"일본인 아저씨가 낚시 미끼를 찌에 다는 장면","-1#":"사람이 죽었다는 소식과 곽도언이 식사하는 장면\n그리고 딸이 나타나서 누가 죽었는지 묻는다사건 현장에 가니 피부가 심상치 않고\n눈에 빛을 잃었다.두번째 현장에 가니 주술의식을 행한듯한 흔적","-2#":"산에서 굴러떨어진 사람은\n무심코 생 고기를 먹고 있는 외지인을 본다외지인은 눈이 빨개져서 굴러떨어진 사람을 위협","-3#":"싹다 그 일본 양반이 오고나서 그런거 아뇨버섯 성분이 잔뜩 검출되었다","공포란-무엇일까#공포란 무엇일까?":"사람의 뇌는 예측하는 기계다.\n이 예측하는 기계가 온전히 동작하지 않을때,\n신체의 부정적 반응과 더불어 두려움이 작동한다.\n낯선 존재와 해석되지 않는 기호와 두려움은 사유를 유발시킨다.지식이란 무엇인가?\n입증 가능한 참된 믿음"}},"/obsidian/*obsidian":{"title":"궁극의 오프라인 마크다운 에디터","data":{"":"옵시디언은 너무 많은 플러그인 탓에 진입장벽이 존재하지만 그만큼 수많은 기능들을 내포하고 있는 사랑받는 마크다운 에디터이다. 웬만한 유료 에디터의 모든 기능들을 무료로 쓸 수 있음에도 불구하고 체계적으로 문서를 관리할 수 있다.","플러그인#플러그인":"plugin_terminal : 옵시디언을 깃과 연동하기 위해 깃 플러그인을 사용해도 되지만 터미널을 쓴다면 더 안전하게 사용할 수 있지 않을까."}},"/obsidian/plugin_terminal":{"title":"터미널 플러그인","data":{"":"옵시디언 커뮤니티 플러그인에 찾아보면 유일한 터미널 플러그인이 하나 있다."}},"/por_canvas/develop_log":{"title":"Develop Log","data":{"":""}},"/por_canvas/what_is_por_canvas":{"title":"전제조건","data":{"":"폴캔버스는 제텔카스텐, 즉 세컨드브레인 제작을 위한 마크다운 편집기입니다.폴캔버스의 por은 path-of-reason의 줄임말로, 근거의 경로를 뜻하며, 연결가능한 생각을 시각화하는데 목표점이 있습니다.==연결가능한 생각들의 시각화== 이 기능이 의미하는 핵심가치는 프랑의 유명한 현대철학자 들뢰즈의 리좀개념에 근거하고 있으며, 고대 사상인 도가사상, 들뢰즈의 리좀을 지나 현대뇌과학적 사실을 관통하는 본질을 담아내고자 하는데 의의가 있습니다.폴캔버스를 사용하신다면 제텔카스텐을 따로 공부하지 않더라도 제공되는 가이드에 의해 자동적으로 학습하게 되는 경험을 얻을 수 있습니다.더 나아가 내가 명확하게 학습한것들에 대해 언제든지 극한으로 압축된 읽기자료를 통해 그당시의 생각을 구조적으로 인지할 수 있게 도와줍니다.이는 교육혁명의 시발점을 이끌어내고자 하는 의도가 담겨있습니다.적어도 학습에 있어서 교수자들이 늘 반복하는 일들이 있습니다. 이 반복되는 교육의 패턴은 학습자의 학습상황을 파악하고 그 상황에 적합한 교육 자료를 서치하여 제공하고, 목표학습지점까지 학습의 방향성을 순차적으로 제시해주는데 큰 의의가 있습니다.학습자는 교수자의 이런 디테일한 피드백을 통해 목표학습지점에 도달하는데 거추장스러운 오개념 오인지를 최대한 회피하고 최단경로로 학습이 가능하게 됩니다. 이때 가장 큰 장점은 학습에 대한 끈기 지속력 인내심이 부족한 학생이더라도 목표학습을 도달하는데 큰 도움을 준다는 점입니다.이런 디테일한 피드백이 필요한 이유는 아주 단순합니다. 우리가 아무것도 사전정보를 알지 못했던 지역에 여행을 갔는데, 한정된 자원으로 목적지를 최소한의 시행착오로 찾아야할때가 있을겁니다. 그럴때 해당 지식을 갖춘 이방인의 도움을 통해 우리는 보다 쉽고 빠르게 목적을 달성할 수 있습니다. 전혀 가보지 못한 길이더라도 당황하지 않고 꾸준히 어딘가로 이동할 수 있도록 돕는것과 같습니다.생각과 근거의 경로는 이런 디테일한 피드백을 사람이 아닌 자료의 관계를 기반으로 피드백을 줄 수 있게 됩니다.이때 교수자의 피드백은 그래프연산에 의해 구성됩니다.학습자의 학습상태와, 목표학습개념이라는 두 극단 사이의 간극을 경로를 통해 매워가는 과정인 셈입니다. 이 중간경로에서 막다른길이 나온다는것은 그 다음 지점을 건너갈 힘, 내재된 개념이 부족하기 때문에 발생하는 것으로, 이런 결핍을 교수자가 인지하고, 해당 지점과 결핍개념간의 그래프 연산을 통해 경로 개념들을 순차적으로 설명하여 이동경로상 장애물들을 극복해나가는 것입니다.즉, 학습자에 대한 피드백은 언제나 늘, 경로검색이 관여하고있고, 경로검색은 사실상 교수자의 사고방식, 즉 우리의 사고 자체라고 볼 수 있습니다.이런 학습문제를 해결하기 위한 시도들은 현재까지 다양하게 이루어지고 있으나, 그래프 연산을 이용한 솔루션은 전무합니다.때문에 이 기술이 온전히 만들어진다면 교육에 혁명이라는 바람이 불어올것으로 예측하고있습니다.하지만 이런 기술들이 실현되기 위해서는 잘 가공된 데이터집합이 구축되어야합니다.그래프 탐색이 가능한 데이터 순수성을 위해 순수를 지향하게 도와주는 저작도구를 만들고있습니다.여기서 말하는 데이터 순수성은 마치 프로그래머들이 말하는 solid원칙과 유사합니다.\nSRP(Single Responsibility Principle): 단일 책임 원칙\nOCP(Open Closed Priciple): 개방 폐쇄 원칙\nLSP(Listov Substitution Priciple): 리스코프 치환 원칙\nISP(Interface Segregation Principle): 인터페이스 분리 원칙\nDIP(Dependency Inversion Principle): 의존 역전 원칙\n\n이 원칙은 객체지향 프로그래밍 설계의 원칙으로 이 원칙을 최대한 따르며 만들어야, 복잡도 결합도를 낮추고, 응집도를 높일 수 있게됩니다.물질이 원자로 구성되어 구조를 만들어 어떤 역할을 수행해내듯, 사람의 사고방식의 최소화된 형태를 개념이라고 부를 수 있습니다.단일책임원칙은 하나의 개념에 대한 충분한 설명과 연결가능한 개념들이 모두 연결되어야 하며, 연결가능하지 않음에 대해 명백하게 불가능해야합니다."}},"/programming/elixir/정보들":{"title":"정보들","data":{"":"https://seokjun.kim/elixir-phoenix-liveview-svelte-how/엘릭서 피닉스 라이브뷰 스벨트 튜토리얼"}},"/programming":{"title":"Rust","data":{"":""}},"/programming/mac/*mac":{"title":"*mac","data":{"":"한영전환 shift + space 로 변환하기\nyabai 개발자의 맥북 윈도우 매니저\nzsh, ohmyzsh 터미널을 이쁘게 편하게"}},"/programming/mac/hangul":{"title":"맥에서 한영키 전환 shift + space 로 변경하기","data":{"":"맥에서 한영키를 이런 저런 바인딩해서 사용하는 경우가 있는데,\ncapslock키로 바인드하는 경우 입력시간이 조금 길어지면 한영키 전환이 아닌\n대문자모드로 변경되는 경우가 있어 입력오타가 자주 발생한다.\n그렇다고 기본 변환인 ctrl + space 를 사용하자니 맥북 키보드에선\nfn 키 앞에숨어있어서 불편하고 외장키보드를 사용한다 해도 새끼손가락을\n제법 아래까지 내려야한다는 점에서 또 불편하다.구름 입력기를 사용하면 shift + space 키로 변경가능한 옵션을 제공하는데,\n모든곳에서 전혀 문제가 없지만 빔에서 사용시 띄어쓰기가 입력된다는점이다.다행히 맥에서는 핫키를 관리하는 파일이 있다. 해당 파일을 열어보자.","핫키파일#핫키파일":"그림처럼 파일이 깨져서 나오는데, 파일이 바이너리로 컴파일 되어있기 때문이다.\n이 파일은 xml 파일로 구성되어져 있으니 컨버팅이 필요하다.","컨버팅#컨버팅":"plutil -convert xml1 ~/Library/Preferences/com.apple.symbolichotkeys.plist","키설정-변경#키설정 변경":"파일이 잘 보이고 이제 문제의 한영키 셋팅에 가서 수정하면 된다.\n그림과 같이 61번 키의 내부 배열에서 마지막 숫자를 131072로 바꿔주자.\n저장하고 이후 다시 바이너리 파일로 컨버팅이 필요하다.","컨버팅-1#컨버팅":"plutil -convert binary1 ~/Library/Preferences/com.apple.symbolichotkeys.plist\n이제 맥을 리부트하면 한영전환이 변경된다."}},"/programming/mac/yabai":{"title":"yabai 맥 윈도우 매니저","data":{"":"맥 사용자라면 누구나 윈도우 매니저를 경험해봤을 것이다.\n맥에서도 기본적으로 제공되는 스테이지매니저가 있다.\n\n그 외에도 무료 윈도우 매니저인 Rectangle이 아주 유명한데, 특징은 모두 마우스 전용이라는 점이다.개발자들은 특성상 마우스보다 키보드가 더 가깝고 익숙해서 이런 불편함을 공감하는 제작자분이 yabai를 만들어주었다.","yabai#yabai":"야바이는 마우스 없이\n창의 포커스를 이동하거나\n창의 위치를 전환\n창의 디스플레이를 전환\n자동레이아웃\n등의 대표적인 기능을 지원한다.\n\n사용하면 다음과 같은 화면을 볼 수 있다.\n\n깔끔하다.","야바이-설정#야바이 설정":"야바이 설정은 ~/.config/yabai/yabairc 파일에 보관한다.\n# bap stack or float\nyabai -m config layout bsp\n\nyabai -m config window_placement second_child\n\n# padding\nyabai -m config top_padding 12\nyabai -m config bottom_padding 12\nyabai -m config left_padding 12\nyabai -m config right_padding 12\nyabai -m config window_gap 12\n\n# mouse settings\nyabai -m config mouse_follows_focus on\nyabai -m config mouse_modifier alt\n\n# set focus follows mouse mode (default: off, options: off, autoraise, autofocus)\nyabai -m config focus_follows_mouse autoraise\n\n# left click drag move\nyabai -m config mouse_action1 move\n\n# right click drag resize\nyabai -m config mouse_action2 resize\n\nyabai -m mouse_drop_action swap\n\n# example: show shadows only for floating windows\nyabai -m config window_shadow float\n\n# Disable specific apps\nyabai -m rule --add app=\"^System Settings$\" manage=off\nyabai -m rule --add app=\"^Calculator$\" manage=off\nyabai -m rule --add app=\"^Karabiner-Elements$\" manage=off\nyabai -m rule --add app=\"^카카오톡$\" manage=off\n야바이는 기본적으로 터미널 명령어를 통해 명령이 실행되는데 이 명령을 대신 전달해줄 키맵핑 프로그림이 필요하다.","skhd-simple-hotkey-daemon-for-macos#skhd (simple hotkey daemon for macos)":"skhd를 사용하여 야바이를 조작할 수 있다.","설정#설정":"# https://github.com/josean-dev/dev-environment-files/blob/main/.config/skhd/skhdrc\n# https://github.com/koekeishiya/skhd\n\n# Changing window focus\nalt - j : yabai -m window --focus south\nalt - k : yabai -m window --focus north\nalt - h : yabai -m window --focus west\nalt - l : yabai -m window --focus east\n\n# Change focus between external displays\nalt - s : yabai -m display --focus west\nalt - g : yabai -m display --focus east\n\n# move window to display left and right\nshift + alt - s : yabai -m window --display west; yabai -m display --focus west;\nshift + alt - g : yabai -m window --display east; yabai -m display --focus east;\n\n# Rotate layout clockwise\nshift + alt - r : yabai -m space --rotate 270\n# flip along y-axis\nshift + alt - y : yabai -m space --mirror y-axis\n# flip along x-axis\nshift + alt - x : yabai -m space --mirror x-axis\n# toggle window float\nshift + alt - t : yabai -m window --toggle float --grid 9:9:1:1:7:7\n\n# maximize window\nctrl + alt - return : yabai -m window --toggle zoom-fullscreen\nctrl + alt - m : yabai -m window --toggle zoom-fullscreen\n\n# space balance reset\nctrl + alt - e : yabai -m space --balance\n\n# swap\nshift + alt - h : yabai -m window --swap west\nshift + alt - j : yabai -m window --swap south\nshift + alt - k : yabai -m window --swap north\nshift + alt - l : yabai -m window --swap east\n\n# move\nctrl + alt - h : yabai -m window --warp west\nctrl + alt - j : yabai -m window --warp south\nctrl + alt - k : yabai -m window --warp north\nctrl + alt - l : yabai -m window --warp east\nctrl + alt - left : yabai -m window --warp west\nctrl + alt - up : yabai -m window --warp north\nctrl + alt - down : yabai -m window --warp south\nctrl + alt - right : yabai -m window --warp east\n\n# move window to prev and next space\nshift + ctrl + alt - h : yabai -m window --space prev;\nshift + ctrl + alt - l : yabai -m window --space next;\nshift + ctrl + alt - left : yabai -m window --space prev;\nshift + ctrl + alt - right : yabai -m window --space next;\n\n# move window to space #\nshift + alt - 1 : yabai -m window --space 1;\nshift + alt - 2 : yabai -m window --space 2;\nshift + alt - 3 : yabai -m window --space 3;\nshift + alt - 4 : yabai -m window --space 4;\nshift + alt - 5 : yabai -m window --space 5;\nshift + alt - 6 : yabai -m window --space 6;\nshift + alt - 7 : yabai -m window --space 7;\n\n\n# stop/start/restart yabai\nctrl + alt - q : yabai --stop-service; skhd --stop-service\nctrl + alt - s : yabai --start-service; skhd --start-service;"}},"/programming/mac/zsh,_ohmyzsh":{"title":"zsh, oh my zsh","data":{"":"개발자라면 항상 터미널을 끼고 살게 된다. 터미널을 끼고 살다보면 기본 터미널이 가진 불편함을 지속적으로 느끼게 되는데, 선배개발자들도 마찬가지였는지 여러가지 터미널에서 유용한 도구들을 만들어두었다.그중 하나가 지금 소개할 zsh이다.zsh는 유닉스 계열 os에서 사용되는 텍스트 기반 쉘로 다음과 같은 기능들을 제공한다.\n강력한 텍스트 편집 기능\n강력한 셸 스크립팅 기능\n강력한 자동 완성 기능\n강력한 히스토리 기능\n강력한 배경 작업 관리 기능\n강력한 테마 기능\n\n이중에서 가장 강력한 점은 이쁜 테마를 지원하는 oh-my-zsh이다.","oh-my-zsh#oh my zsh":"오마이즈쉬를 깔아야 테마질을 할 수 있다.\n또한 zshrc(즈쉬설정파일)에 플러그인의 이름을 입력하는것으로 플러그인 설치가 가능하다.(되는 플러그인이 있고 안되는것도 있다)","powerlevel10k#powerlevel10k":"파워레벨은 터미널 테마를 내 입맛에 맞게 커스터마이징을 쉽게 할수있도록 지원해준다. 물론 이 방법을 쓰지 않고도 커스터마이징이 불가능하진 않지만, 파워레벨을 사용하면 몇가지 예제를 보여주면서 터미널에서 맘에 드는 숫자만 입력하면 해당 테마를 얻을 수 있도록 도와준다.","zap#zap":"잽은 오마이즈쉬에서 사용가능한 플러그인 매니저이다.\n잽을 사용하면 플러그인 관리가 매우 편리하다.","플러그인#플러그인":"","별칭#별칭":""}},"/programming/neovim/*lunarvim":{"title":"루나빔","data":{"":"개발자라면 누구나 vi, vim, nvim 등을 쉽게 접하고 한번쯤은 써보게 된다.vim 은 아주 오래된 텍스트 에디터로 개발자에게 사랑받아왔던 개발도구인데, 필자도 유튜브에서 빔을 이쁘게 꾸며놓고 프로그래밍을 멋지게 해내는 영상들을 보고 한번쯤 써보고 싶다는 생각을 해왔다.이후 삽질의 시간을 거쳐 루나빔에 대해 알게 되었고 지금은 커스터마이징의 수렁에서 조금은 헤어나오게 되었다.루나빔은 neovim 이후로 나온 패키징 중에서 최강자로 자리잡고 있다. 비슷한 포지션에 nvchad, astrovim등이 있으나, 많은 사람들은 루나빔을 가장 잘 구성된 패키지라고 생각하고 있다. 필자도 이것 저것 깔아서 시도해봤지만.. 빔에 대해 잘 모르는 상태에서 가장 설정없이 쓰기 좋은 도구임에는 틀림없다고 생각하게 되었다.","설치#설치":"루나 빔 설치는 공식 홈페이지를 따르면 되지만 종종 필요한 의존성이 없어서 설치 안되는 경우들이 있다. 루나빔을 설치하기 위해선 네오빔(9.0버전 이상)과 메이크(컴파일관련)가 필요하다.네오빔을 설치하는 방법은 브류(맥), apt(리눅스), scoop(윈도우) 등의 cli 소프트웨어 매니저를 이용한 방법이 있고 깃허브에서 이미지를 다운로드하거나 클론하는 방법 등등이 있는데, 리눅스에서 apt를 사용하게 되면 최신버전이 아닐 수 있으니 주의가 필요하다. 웬만하면 네오빔 깃허브를 찾아가서 설치하는게 좋다.메이크는 패키지 매니저를 통해 받도록 하자.","사용가이드내장-플러그인-포함#사용가이드(내장 플러그인 포함)":"shift+k 타입보기\n* 변수명 리팩터링\n플로팅 터미널 사용하기\n기능 단축키 검색하기","스니펫#스니펫":"컨픽루아 파일 분리적용시키기\n리액트 돔 스니펫 사용하기\n커스텀 스니펫 사용하기","추가-플러그인#추가 플러그인":"plugin-nvim-surround : 브라켓 편하게 입력 수정 삭제하기\nplugin-frog : 깃 커밋 트리 보기","설정#설정":""}},"/programming/neovim/asterisk_refactoring":{"title":"* asterisk로 변수명을 리팩터링해보자","data":{"":"","한-파일-내부의-변수명을-변경할-경우#한 파일 내부의 변수명을 변경할 경우":"루나빔에서 특정 변수의 이름을 모두 변경해야할 때가 있다.\n이때 * 키의 도움을 받으면 편하다. 노멀모드에서 커서를 특정 변수명에 위치놓고 *\n키를 누르면 자동으로 해당용어 전체를 셀렉션 해주게 된다. 일종의 매크로인 셈인데 /변수명 을 자동으로 입력해주어 검색을 도와주는 도구이다.(빔에서는 노멀모드에서 / 키를 누르고 키워드를 입력하면 현재 활성화된 문서 전체에서 해당 키워드를 검색하고 셀렉션해준다.)\n\n이제 셀렉트된 변수의 이름을 바꿔보자.노멀모드인 상태로\nciw 를 순서대로 입력하면\n커서가 단어의 중간에 있어도 단어의 시작점부터 변경하게끔 단어를 삭제하고 인서트 모드로 전환된다.\n변수의 이름을 name으로 변경하고\n인서트 모드를 종료(esc)하면\n방금 변환했던 행위가 빔의 . 매크로에 기억되어있기 때문에 반복 가능하다.\nn 키를 눌러서 셀렉션된 다음 대상으로 이동할 수 있고,\n. 키로 이전에 햇던 작업을 반복하면 변수명 변환 리팩터링이 완료된다.","여러-파일에-걸친-변수들을-리팩터링해보자#여러 파일에 걸친 변수들을 리팩터링해보자":"방법은 다르지 않다. 루나빔에서는 변수를 레퍼런스 삼는 모든 지점들을 찾아내주는 기능이 있다. 단축키는 g + r(reference)을 기본값으로 한다.\n참고\ng + d(definition)\ng + l(lsp error, warn...)\n\n\n\n변경할 이름을 찾아서 *을 먼저 눌러주고,\n해당 이름을 사용하는 레퍼런스를 검색하여 하나씩 변경하면 된다. 그러면 현재 파일에서 해당 이름을 사용하는곳을 모두 검색하면서 이 이름을 사용하는 모든 파일의 위치를 찾아준다.\n포커스가 현재 레퍼런스 창에 가있기 때문에 Enter키를 입력하면 해당 레퍼런스 위치로 이동하게 되고,\n이때 c + i + w 를 눌러 용어를 변경하면 매크로에 입력된다.\n해당파일에서 다음 변수를 찾기위해 n 키를 입력하여 다음 셀렉트 변수를 찾아내고\n. 키를 눌러 이전에 입력된 이름변경 매크로를 실행시켜준다.\nctrl + j (빔 윈도우 포커스 아래 윈도우로 이동) 키를 눌러 포커스를 레퍼런스 리스트로 옮겨주고\n작업한 파일 외부의 파일로 이동하여 이름변경을 반복해준다."}},"/programming/neovim/divide_lua":{"title":"루아파일 분리하기","data":{"":"루나빔의 설정폴더에 가면 컨픽파일만 덩그러니 있는데, 여기에 조금 설정값을 추가하다보면, 파일 크기가 점점 커져서 가독성이 떨어지게 되는 문제가 발생한다.루아파일도 가벼운 프로그래밍 언어이다보니, 모듈화시킬수 있는데, 기본적으로 require키워드를 사용한다.루아파일의 모듈 특징은 lua 폴더에 들어가 있어야 한다는 점이다.\n\n필자는 컨픽파일을 현재 이렇게 사용중이다.컨픽파일에서 별도의 루아파일을 불러올 때 lua폴더에 있는 루아파일을 불러온다는점을 주의하자.만약 루아파일 내부에 새로운 폴더를 만들고 그 내부에 루아파일을 불러올때는 몇가지 규칙이 있다\n\n위 그림과 같이 모듈을 불러오려면 다음의 규칙을 준수하면 된다.\nlua/ 아래에 존재해야한다\nlua/file.lua : require filename\nlua/folder/init.lua : require \"folder\"\nlua/folder/file.lua : require \"folder.file\"\n\n\nprint(\"custom init.lua print\")\n\nprint(\"hello by print-hello.lua\")\n입력해놓고 빔을 다시 켜면 설정파일이 로드되면서 다음과 같은 프린트가 뜬다.\n\n루아파일 가져올때 종종 오류메시지가 뜨는데, 종료후 실행해봐야 해결되는 케이스가 있다. 오류메시지 없에려고 너무 노력하지 말고, 설정이 잘 완료되면 일단 빔을 재부팅해보자."}},"/programming/neovim/floating_terminal":{"title":"플로팅 터미널 사용하기","data":{"":"루나빔에서 특별한 설정없이 터미널을 사용하는 방법은 다섯가지 정도가 있다.\n:terminal 명령어를 입력해 새탭에 터미널을 띄우\nMeta + 1 키를 입력해 하단 스플릿 터미널 띄우기\nMeta + 2 키를 입력해 우측 스플릿 터미널 띄우기\nMeta + 3 키를 입력해 플로팅 터미널 띄우\nctrl + \\ 키를 입력해 터미널 토글하기\n\n필자의 맥북에는 무슨일인지 메타키(커맨드키)가 먹히지 않아 2,3,4번 단축키 사용을 하지 못하고 있다. 남은 방법은 1번과 5번인데1번은 매우 번거로울 뿐만 아니라 탭에 있을 때 터미널에 포커싱 되어있다면 포커싱을 강제로 종료하는 방법을 못찾았다. 그래서 터미널을 매번 종료해야만 하는 번거로움이 있다.5번 선택지를 사용한다면 자동적으로 플로팅 터미널이 뜨게 된다. (버퍼에 다른 옵션의 터미널이 없을경우 기본값)"}},"/programming/neovim/flog":{"title":"Flog 깃 커밋 트리 뷰어","data":{"":"여타 IDE를 사용할때면 누가 어떤 작업을 진행했고 푸시했는지 확인시켜주는 도구들이 있다. vscode 에서는 깃렌즈라던지 훌륭한 익스텐션이 존재한다. 빔에도 마찬가지로 쓸만한 플러그인이 있다. 이번에 소개할 프로그 플러그인이다.\n\n프로그를 사용하면 위처럼 소스트리를 한눈에 볼 수 있다. 텍스트기반이다보니 여타 IDE들이 그래픽으로 보여주는 정도까지의 화려함은 없지만 개발자 특유의 멋을 낼 정도는 충분하다.설치는 간단하다.\nlvim.plugins = {\n-- git viewer\n{'rbong/vim-flog'},\n{'tpope/vim-fugitive'},\n플러그인 객체에 붙여넣고 빔을 리부팅 시키면 된다.설치가 완료됐으면 노멀모드에서 :F 키를 입력해 플러그인을 활성화 시켜보자. 실행 명령어는 세가지다.\nFlog (트리뷰어)\nFloggit (스태이터스 보기)\nFlogsplit (트리뷰어 왼쪽에 스플릿뷰로 보기)\n\n\n\nFloggit을 입력하면 위와같은 화면이 나타나고 각 문서의 상태를 알수있다. Header가 변경되고, LICENSE가 삭제되었다.매번 명령어를 입력하기 곤란하니 단축키를 등록해보자.\n~/.local/share/lunarvim/lvim/lua/lvim/core/which-key/lua 파일에서 g (git) 키를 찾아 다음과 같이 수정해준다.\n\n이제 잘 동작한다."}},"/programming/neovim/git_shorcut":{"title":"Git Shorcut","data":{"":"깃 단축키는 위치키(플러그인)에 매핑되어있다.~/.local/share/lunarvim/lvim/lua/lvim/core/which-key/lua 에 설정되어있다.\n\n설정파일에 접근하기가 불편하니 다음과 같이 바로가기를 만들어두는 편이 좋다.\n\nLink를 만드는 방법은 다음과 같다.\n> ln -s ~/.local/share/lunarvim/lvim/lua/lvim ~/.config/lvim-origin"}},"/programming/neovim/hover_info(view_type)":{"title":"K (shift + k) 타입보기","data":{"":"여타 ide의 경우 추론된 혹은 명시된 타입을 보기위해서는 변수 위에 마우스를 올리면 나타난다.\n\n빔에서는 일반적으로 마우스를 사용하지 않기 때문에 키보드 맵핑을 통해 이를 해결하는데\n루나빔의 경우 타입이나 함수 시그니처를 보기위해서는 K 를 입력해주면 된다.\n\nKK 즉 두번입력하면 호버링된 인포메이션 창에 포커스를 옮길수 있다. 포커스가 뜨면 V비주얼모드로 라인복사하기 수월하다."}},"/programming/neovim/plugin-nvim-surround":{"title":" nvim surround plugin ","data":{"":"빔의 기본설정에는 브라켓을 씌우는 로직이 없어서 일일히 찾아가서 씌워줘야 한다.\nvscode나 다른 여타 IDE 를 사용하면 브라켓을 씌울 글자를 셀렉트하고\n브라켓을 입력하면 바로 입력된다. 키보드 입력은shift + opt + arrowkey + [\n이렇게 네번의 키입력이 있을때 작동한다.이번에 소개하는 플러그인은 해당 위치를 직접 찾아가서 브라켓을 씌우지 않고\n다른 IDE 에서 사용하듯이 적당한 키입력을 통해 브라켓을 씌워주는 플러그인이다.","설치#설치":"설치법은 깃헙페이지에서 제시한대로 다음과 같다.\nlvim.plugins = {\n{\n\"kylechui/nvim-surround\",\nversion = \"*\", -- Use for stability; omit to use `main` branch for the latest features\nevent = \"VeryLazy\",\nconfig = function()\nrequire(\"nvim-surround\").setup({\n-- Configuration here, or leave empty to use defaults\n})\nend\n}\n}\n/.config/lvim/init.lua 파일을 열고 위 설정값을 입력한 후 빔을 실행하면 플러그인 매니저인 Lazy가 자동으로 설치를 해준다.","사용법#사용법":"이후 메뉴얼에서 소개하는 사용방법을 통해 브라켓 씌우기, 브라켓 변형하기등의\n기능을 사용할 수 있다.\nOld text                    Command         New text\n--------------------------------------------------------------------------------\nsurr*ound_words             ysiw)           (surround_words)\n*make strings               ys$\"            \"make strings\"\n[delete ar*ound me!]        ds]             delete around me!\nremove <b>HTML t*ags</b>    dst             remove HTML tags\n'change quot*es'            cs'\"            \"change quotes\"\n<b>or tag* types</b>        csth1<CR>       <h1>or tag types</h1>\ndelete(functi*on calls)     dsf             function calls"}},"/programming/neovim/react_snipperts":{"title":"리액트 html 스니펫 활성화하기","data":{"":"루나빔을 처음 설치하고 리액트를 작성하면 얼마 지나지 않아 크게 당황하고 마는데, 이유는 돔 태그들에 대한 스니펫이 작동하지 않기 때문이다. 루나빔의 레이지 플러그인은 파일 확장자를 보고 자동적으로 언어관련 모듈을 설치해서 lsp나 코드하이라이팅을 지원해주는데, 리액트파일을 자바스크립트 파일로 인식한 나머지 리액트 스니펫을 작동시켜주지 않는듯하다.하지만 이미 내장플러그인들로 충분히 기능사용이 가능하기 때문에 약간의 설정만 변경해주면 무리없이 사용이 가능하다.~/.config/lvim/config.lua 파일을 열고 다음과 같은 설정값을 입력해주고 에디터를 리부트 시켜주자.\n\nlocal lspconfig = require('lspconfig')\nlocal configs = require('lspconfig/configs')\nlocal capabilities = vim.lsp.protocol.make_client_capabilities()\ncapabilities.textDocument.completion.completionItem.snippetSupport = true\n\nlspconfig.emmet_ls.setup({\ncapabilities = capabilities,\nfiletypes = { \"css\", \"eruby\", \"html\", \"javascript\", \"javascriptreact\", \"less\", \"sass\", \"scss\", \"svelte\", \"pug\", \"typescriptreact\", \"vue\" },\ninit_options = {\nhtml = {\noptions = {\n[\"bem.enabled\"] = true,\n},\n},\n}\n})\n\n이제 스니펫이 잘 동작할 것이다.설정파일이 커져 복잡해보인다면 루아파일 분리하기를 참고하자."}},"/programming/neovim/searchkeymap":{"title":"기능 단축키 검색하기","data":{"":"이번 팁은.. 사실 조금만 관찰해도 쉽게 찾을 수 있다. 위치 키에서 해당 기능을 소개해주고 있기 때문이다.빔의 단축키 명령어는 위치키(루나빔 기본내장)를 통해 수많은 조합으로 매핑될 수 있는데, 루나빔은 기본적인 셋팅값들이 제법 많이 매핑되어있다. 지금 소개할 키맵핑 정보 찾는 기능도 이미 매핑되어있다.루나빔에서 스페이스(빔에서는 리더키라고 부른다)를 누르고 약 0.5초간 기다리면 사용자가 학습이 덜 됐다는 판단하에 키기 어떤 구성인지 소개를 해준다.\n\n여기서 s가 서치인걸 확인할 수 있고 눌러보면 k에 키맵이 매핑되어있다고 나타난다. 해당 키를 누르면 다음과 같은 검색화면이 뜬다.\n\n검색어를 입력하면 해당기능에 대한 단축키를 찾아낼 수 있다."}},"/programming/neovim/use_custom_snippet":{"title":"커스텀 스니펫 사용하기","data":{"":"빔을 쓰다보면 스니펫 정도는 만들어서 쓸 수 있어야한다.스니펫 플러그인이 여럿있겠지만, 루나빔에 내장된 스니펫 플러그인을 사용하도록 하자.루나빔에서 사용하는 내장 스니펫 플러그인은 luasnip이라는 이름이다.\n이 플러그인은 vscode에서 사용되는 모든 스니펫을 다운로드해서 가져오고 사용할 수 있도록 도와준다.또 이 방식에 따라 커스텀 스니펫 또한 만들어 사용할 수 있다.\nrequire(\"luasnip/loaders/from_vscode\").load { paths = { \"~/.config/lvim/snippets/my-snippets\" } }\nrequire를 보면 알겠지만, 해당 스니펫은 vscode스니펫 설정을 로드하는 방식이다.\n해당 스니펫을 제작할때는 두가지 파일이 필요하다.\n{\n\"name\": \"wisnips\",\n\"author\": \"wis\",\n\"engines\": {\n\"vscode\": \"^1.11.0\"\n},\n\"contributes\": {\n\"snippets\": [\n{\n\"language\": [\"svelte\"],\n\"path\": \"./svelte.json\"\n}\n]\n}\n}\n\n{\n\"console log input\": {\n\"prefix\": \"clg\",\n\"body\": \"console.log(${0})\",\n\"description\": \"wisnip : console.log()\"\n}\n}\n\n바디에 ${0} 이 있는걸 확인할 수 있는데 스니펫불러오면 이 곳에 커서가 포커싱된다. 이후 ${1} ${2} ${3} 으로 탭키 누르면 자동으로 다음 항목으로 옮겨지기 때문에 유용하게 사용할 수 있다.\n두 파일 모두 json파일로 구성되어져있기 때문에 제이슨 형식에서 벗어나면 파싱에러를 일으키며 동작을 안할수도 있다. 특히 컴마, 사용에 주의하도록하자."}},"/programming/rust/basic_syntax/*rust_basic_syntex":{"title":"*rust Basic Syntex","data":{"":"1.hello_world\n2.comment\n3.primitive_types\nprint\ntraits\nown_burrow\nstring"}},"/programming/rust/basic_syntax/1.hello_world":{"title":"println 함수로 \"hello world\" 작성하기","data":{"":"","cargo-new프로젝트-생성#cargo new프로젝트 생성":"> cargo new hello_rust\n프로젝트를 생성하면 루트폴더에 다음과 같은 파일이 생성되어있다.\n이 파일을 통해 디펜던시를 관리할 수 있다.\n[package]\nname = \"hello_rust\"\nversion = \"0.1.0\"\nedition = \"2021\" # 현재시간이 아니라 카고의 버전을 뜻한다.\n\n[dependencies]\n실행파일로 이동해보자.\nfn main() {\nprintln!(\"hello, world!\")\n}","hello-world-컴파일과-실행#hello, world! 컴파일과 실행":"기본셋팅값으로 헬로월드 출력문이 작성되어있다.\n개별 파일을 실행할때는 개별로 컴파일 하고 이후 바이너리 파일을 직접\n실행시켜줄 수 있다\n> rustc src/main.rs\n> ./main\nhello, world!\nrustc 명령어를 통해 코드를 컴파일하고이를 실행하려면 빌드하고 컴파일된 파일을 실행해줄 수 있으나,\n러스트의 cargo는 이 두 과정을 한번에 처리할 수 있는 구문을 제공하고 있다.\n> cargo run\nhello, world!"}},"/programming/rust/basic_syntax/2.comment":{"title":"주석","data":{"":"","블럭-주석#블럭 주석":"일반적인 주석은 슬래시 // hello로 사용한다.\nfn main() {\n// hello rust\nprintln!(\"hello, world!\")\n}","인라인-주석#인라인 주석":"러스트의 인라인 주석은 다음과 같이 사용한다.\n/* hello */\nfn main() {\nlet x/*: i16 */ = 10;\n}"}},"/programming/rust/basic_syntax/3.primitive_types":{"title":"타입","data":{"":"","원시타입-스택#원시타입 (스택)":"양의 정수 (unsigned integer)\nu8  : 0 ~ 255\nu64 : 0 ~ 18,446,744,073,709,551,615\n\n\n정수 (signed integer)\ni8 : -128 ~ 127\ni64 : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\n\n\n부동소수점\nf32 : -3.4_10^38 ~ 3.4_10^38, 대략 소수점 이하 7자리 수 -> 잘 안씀\nf64 : f32대비 속도차이가 잘 나지않아 자주 씀\n\n\n논리 : true / false\n문자 : 'a', 유니코드, u8과 호환 => 형변환 가능\nlet x:u8 = 100; print!(\"{}\", x as char); => d","복합타입-힙#복합타입 (힙)":"문자열 (문자타입의 집합 - 원시타입일수 없음)\n&str : \"hello\", 레퍼런스타입, 소유권이 없음\nString : \"hello\".to_string(), String::from(\"hello\"), 소유권있음\n\n\n튜플 : ('a', \"hello\", 32)\n배열 : [1, 2, 3, 4, 5] 배열의 내부는 같은 타입들로 구성\n구조체\n열거형\n클래스"}},"/programming/rust/basic_syntax/own_burrow":{"title":"소유권 (for safety)","data":{"":"","owned-dataname#owned data(name)":"모든 데이터는 어느 한 시점에 반드시 하나의 소유자를 갖는다. 소유자는 주로 변수이다.\n모든 데이터는 태어나는 시점과 소멸하는 시점이 한번씩만 있다.\n모든 데이터의 소유권은 어느 한 소유자에게서 다른 소유자로 이전될 수 있다.\n모든 데이터는 특수한 상황에서 공동 소유자가 존재할 수 있다.\nheap","burrowed-dataname#burrowed data(&name)":"다른 소유자에게서 빌려온 데이터\n어느 한 소유자는 자신의 데이터를 무한히 반복하여 빌려줄 수 있다.\n빌려주는 사람(소유자)는 반드시 빌려간 사람보다 오래 살아야한다.\nstack"}},"/programming/rust/basic_syntax/print":{"title":"프린트 함수","data":{"":"","-출력#\"{}\" 출력":"러스트의 프린트 함수는 다음과 같이 사용된다\nlet x = 100;\nprintln!(\"{}\", x);\n\n100\n이때 프린트는 위와같은 방식으로 x라는 변수를 받아서 출력된다. x의 값은 정수로 잘 출력된다.","-display-trait-debug-trait#\"{:?}\" Display Trait, Debug Trait":"let x = vec![1,2,3,4];\nprintln!(\"{x}\")\n---> err\n\nprintln!(\"{:?}\",x)\n---\n[1,2,3,4]\n러스트에서는 벡터나 배열같은 복합타입을 print할 때 특정 조취를 취하지 않으면 다음과 같은 오류를 나타낸다.\nrustc: `Vec<{integer}>` doesn't implement `std::fmt::Display`\n// 벡터타입은 디스플레이를 구현하고 있지 않습니다.\nthe trait `std::fmt::Display` is not implemented for `Vec<{integer}>`\n// 디스플레이 트레이트는 벡터유형에 구현되지 않았습니다.\nin format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead [E0277]\n// 포멧 스트링에서 `{:?}`를 사용하거나 `{:#?variable}`을 사용할 수 있습니다.\n여기서 두가지 개념(트레이트와 프린트)에 대한 힌트가 나오는데 트레이트는 타입에 구현되어 사용되어지는것으로 이해할 수 있다. 만약 벡터유형에 디스플레이 트레이트가 구현되어져 있었다면 프린트함수에서 잘 출력될것으로 생각할 수 있고, 디스플레이 트레이트가 없지만 벡터유형의 경우 스트링 포멧이 필요할 때 {:?}를 사용할 수 있다는 점이다.즉 프린트함수는 스트링 포멧을 출력하기 위한 함수로 볼 수 있고, {:?} 를 사용하여 벡터유형을 스트링포멧으로 변환시켜준다고 이해할 수 있다.이때 \"{:?}\"는 출력대상(벡터) 유형이 가진 디버그 트레이트를 대상으로 한다.트레이트에 대한 추가설명은 traits에서 확인하자.","x-프리티-프린트#\"{x}\" 프리티 프린트":"원래 프린트 함수는 println!(\"{}\", x)꼴로 작동하지만 최근 러스트에서 프리티 프린트 기능이 추가되어 println!(\"{x}\")꼴의 형태도 출력을 지원하게 되었다.","p-포인터-메모리-주소#\"{:p}\" 포인터 (메모리 주소)":"let a = 10;\nlet b = &a;\nprintln!(\"{:p}\", b);\n---\n0x16cfe29dc\n러스트에서는 포인터 출력을 할 수 있는데 참조형 자료를 출력할때 해당 메모리가 어딨는지 찾아낼 수 있다.","기타-출력-형식들#기타 출력 형식들":"\"{:x}\" hexadecimal\n\"{:o}\" octal\n\"{:b}\" binary\n\"{:%}\" percent\n\"{:,}\" 큰수 천단위 구분자\n\"{:.2f}\" 소수점 두자리\n\"{:.*f}\" 소수점 출력"}},"/programming/rust/basic_syntax/string":{"title":"문자열","data":{"":"","str#&str":"레퍼런스 스트링 타입은 데이터가 스택에 보관된다.\n레퍼런스 스트링은 다음처럼 사용할 수 있다.\nlet x = \"hello world\";\n레퍼런스 스트링타입은 레퍼런스의 특징을 고스란히 갖고 있다.\n\"hello world\"라는 데이터를 레퍼런스로 소유권을 빌려왔기 때문에 다른곳에서 사용한다고 해도 어딘가에 있는 소유권이 소멸되지 않는다. 즉 변수가 소유권을 관리하지 않기 때문에 여러번 반복사용해도 문제가 없다.\nlet x = \"hello world\";\nprintln!(\"{x}\");\nprintln!(\"{x}\");\n---\nhello world\nhello world\n타입을 알아보면 다음과 같이 표시된다.\n\n명시된 타입을 보면 사이즈와 주소값이 나타나는데, 주소값은 스택영역에서 관리한다.","string#String":"std::string::String : std library, string module, String structureString 타입을 사용하는 방식은 다음 두가지 방식이 대표적이다.\nlet a = std::string::String::from(\"string\");\nlet b = \"string\".to_string();\n첫번째 방법은 String 구조체가 가진 from 트레이트를 이용해 문자열을 정의하는 방법이고 두번째 방법은 to_string()메서드를 통해 레퍼런스 스트링값을 String으로 변환시키는 방법이다. 구조체를 use하지 않고도 사용할 수 있어서 편리하다.","소유권의-위임-새로운-변수에-할당-매개변수로-사용#소유권의 위임 (새로운 변수에 할당, 매개변수로 사용)":"String타입은 구조체에 의해 정의된 타입으로 힙영역에 존재하는 데이터다. (3.primitive_types) 또한 레퍼런스 타입이 아니기 때문에 할당 변수가 소유권을 갖게 된다. 변수의 소유권은 함수에게 위임하거나 다른 변수에게 위임하는 순간 제거된다.소유권이 제거된다는 말은 실제로 이전 변수가 갖고있던 주소값과 주소값이 가리키는 스택의 주소값 모두가 메모리에서 삭제된다는 뜻이다.\nlet x /* 주소값을 스택에 보관 소유권 없음 */ = \"hello world\";\nlet y = x; // 주소값 복사\nprintln!(\"{x}\"); // hello world\nprintln!(\"{y}\"); // hello world 모두 잘 출력\n\nlet a /* 주소값과 소유권을 스택에 보관 */\n= \"string\".to_string(); // 힙영역에 구조체로 저장되어있음\nlet b = a; // 주소값 복사, !소유권 위임!\nprintln!(\"{a}\"); // 데이터에 대한 소유권이 없기 때문에 오류\n---> err\nrustc: borrow of moved value: `a`\nvalue borrowed here after move [E0382]\n\n변수\t변수의 주소값\t스택\t힙\tx : &str\t0x001\t\"hello world\"\t\txr\t0x002\t0x001\t\ty\t0x003\t\"hello world\" (할당과 동시에 복사됨)\t\tyr\t0x004\t0x002\t\ta : String\t0x005 (양도시 삭제)\tString{address: 0x22} (양도시 삭제)\t\"string\"\tb : String\t0x006\tString{address: 0x22}","size#size":"&str 타입의 사이즈와 String 타입의 사이즈를 조사해보자\nfn main() {\nuse std::mem::{size_of, size_of_val};\n\nprintln!(\"{}\", size_of::<String>()); // 24\nprintln!(\"{}\", size_of::<&str>()); // 16\nprintln!(\"{}\", size_of_val(\"hell\")); // 4\nprintln!(\"{}\", size_of_val(\"hello world hlsdhfkshdfklsadflksafdkhklhaksfdklklhaksdfkalsdhfklha\")); // 64\n}\n사이즈 오브 함수를 이용해서 메모리 사이즈를 조사해보면 문자열의 사이즈는 가변사이즈라는것을 알 수 있다.String 타입은 스택메모리에서 고정된 크기를 가진다고 한다. 그래서 sized type이라고 부르고\n&str 타입은 스택메모리에서 가변적 크기를 가진다고 하여 not sized type이라고 부른다고 한다."}},"/programming/rust/basic_syntax/traits":{"title":"Traits","data":{"":"트레이트는 여러 타입들간에 공통적으로 동작하는 인터페이스로\n함수나 메서드\n타입\n상수\n로 구성된다.\n\n트레이트의 상당수는 어떤 기능이나 작동을 의미한다고 한다.","예1#예1":"예를 들어 print 문서에도 나와있는 std::fmt::Display(스탠다드 라이브러리, 포멧 모듈, 디스플레이 트레이트) 트레이트는 출력되기 위해 필요한 트레이트이다. 프린트로 사용하고 싶다면 디스플레이나 디버그 트레이트를 구현해야한다.","예2#예2":"#[allow(unused_variables)]\n함수 위에 위와같은 어노테이션?을 추가할 수 있는데 unused_variables트레이트를 허용하는 어노테이션으로 해당 함수의 블럭안에서 사용되지 않는 함수가 있어도 컴파일러가 경고를 띄워주지 않는 기능을 한다.","하스켈#하스켈":"하스켈에서는 타입클래스라는 이름으로 동일한 역할을 한다고 한다."}},"/programming/rust/mini_project/0.mini_project(with_chatgpt)":{"title":"러스트로 코드짜기","data":{"":"새로운 언어를 학습할 때 무슨 과제를 해야 효과적으로 학습이 될까? 이런 아이데이션이 필요할때는 인공지능의 도움을 받는게 좋다. 챗지피티에게 물어보았다.\"러스트를 이제막 시작하는 러린이야. 러스트를 효과적으로 학습하기 위해 작은 프로젝트를 해볼수있으면 좋겠는데 아주 아주 쉬운 과제들을 리스트업해줘\"\n러스트를 효과적으로 학습하기 위해 다음과 같은 간단한 프로젝트들을 시도해볼 수 있습니다:\n\n1. 구구단 출력: 1부터 9까지의 숫자에 대해 구구단을 출력하는 프로그램을 작성해보세요.\n2. 소수 찾기: 주어진 범위 내의 모든 소수를 찾아 출력하는 프로그램을 작성해보세요.\n3. 팩토리얼 계산: 주어진 숫자의 팩토리얼을 계산하는 프로그램을 작성해보세요. 여기에서는 순환(recursion)의 개념도 함께 고려해보세요.\n4. 피보나치 수열: 주어진 개수만큼의 피보나치 수열을 출력하는 프로그램을 작성해보세요.\n5. 문자 카운트: 문자열을 입력받아 각 문자가 몇 번 등장하는지 세서 출력하는 프로그램을 작성해보세요.\n6. 텍스트 파일 다루기: 텍스트 파일을 열어서 대문자와 소문자를 서로 바꾸고, 파일에 쓰여진 빈 줄을 세는 기능이 있는 프로그램을 작성해보세요.\n7. 구조체 활용: 학생 데이터(이름, 나이, 성적)를 저장할 수 있는 구조체를 작성하고, 여러 학생들을 벡터에 추가한 후, 성적 기준으로 정렬하는 프로그램을 작성해보세요.\n8. 온도 변환기: 섭씨 온도를 화씨 온도로, 또는 그 반대로 변환해주는 프로그램을 작성해보세요.\n9. 간단한 계산기: 두 개의 숫자와 기본 사칙연산을 입력받아 그 결과를 출력하는 프로그램을 작성해보세요.\n10. 직사각형 구조체: 가로 세로 길이를 가진 직사각형 구조체를 생성하고, 면적과 둘레를 계산하는 메소드를 작성해보세요.\n\n이러한 프로젝트들을 진행하면서 러스트의 기본 문법뿐만 아니라, 변수, 제어문, 함수, 루프, 구조체, 열거형(enum), 모듈, 에러 핸들링, 트레이트 등 여러 주제에 대해 접할 수 있게 됩니다. 각 프로젝트를 완료한 후 다양한 방식으로 개선하거나 확장해보세요. 이를 통해 러스트를 더 잘 이해할 수 있을 것입니다.\n이 과제들을 하나씩 수행해보자."}},"/programming/rust/mini_project/1.multiplication":{"title":"과제 1. 구구단 출력","data":{"":"fn print_multiplication(x: u32, y: u32, result: &mut Vec<String>) {\nresult.push(format!(\"{x}*{y}={}\", x * y));\nmatch y {\n9 => (),\n_ => print_multiplication(x, y + 1, result),\n}\n}\n\nfn print_multiplication_table(x: u32, result: &mut Vec<String>) {\nprint_multiplication(x, 1, result);\nmatch x {\n9 => (),\n_ => print_multiplication_table(x + 1, result),\n}\n}\n\nfn main() {\nlet mut result = vec![];\nprint_multiplication_table(1, &mut result);\nprintln!(\"{:?}\", result)\n}"}},"/programming/tauri/*tauri":{"title":"타우리","data":{"":"타우리는 프론트엔드 기술스택으로 모바일 데스크탑 등 크로스 플랫폼 앱의 제작을 도와주는 도구이다. 비슷한 플랫폼으로 electron을 볼 수 있는데, 타우리만의 장점이 몇가지 있다\n러스트 기반이다\n러스트는 널리 알려진대로 매우 빠르고 효율적인 언어다. 특히 러스트는 가비지컬렉터를 사용하지않고 코드에 의해 수동으로 관리되는데, 이때문에 개발자가 더욱 신경써야 하는만큼 메모리 사용이 효율적이다.물론.. 타우리의 프론트엔드는 리액트나 스벨트등으로 브라우져를 이용하여 동작하므로 이부분에 대한 메모리절감은 없다.\n프론트엔드 기술스택으로 데스크탑앱을 쉽게 만들수 있다\n이게 핵심이다. 웹에서 프론트 개발만 하던 사람이 데스크탑앱을 제작할 수 있다. 모바일 버전은 아직 0.5.1버전으로 베타중이다.\n패키지 사이즈가 매우매우 작다.\n타우리로 앱을 만들어 빌드한 결과가 아주 충격적이었다. 3메가바이트. 일렉트론으로 빌드하게 되면 150메가 바이트정도가 필요하다. 근본적인 차이가 있는데, 타우리는 브라우져를 패키지에 내장하지 않고 os의 기본브라우져를 빌려와서 사용하는 개념이다. 그렇다보니 패키지가 매우매우 작다.","api#api":"타우리를 사용하기 위해서는 프론트엔드의 코드를 SSR로 작성해서는 안된다. 그도 그럴게, 프론트엔드 서버를 굳이 운용할 필요가 없기 때문이다. CSR 혹은 SSG로 작성하게 하고, 서버사이드가 필요한 모든 요소들은 아래 타우리 API의 도움을 받아야 한다.(현재 파일시스템 문서만 작성)\napp\ncli\nclipboard\ndialog\nevent\nfs : 작성완료\nglobalShortcut\nhttp\nmocks\nnotification\nos\npath\nprocess\nshell\ntauri\nupdater\nwindow\n\n필자는 데스크탑에서 문서관리 도구를 만들고 있기 때문에 핵심 api로 파일시스템을 사용하고 있다."}},"/programming/tauri/api_fs":{"title":"file system","data":{"":"타우리의 파일시스템을 사용하려면 타우리 설정파일에 사용할 api를 명시해줘야 한다.\n{\n\"tauri\": {\n\"allowlist\": {\n\"fs\": {\n\"all\": true, // 사용여부 true\n\"readFile\": true,\n\"writeFile\": true,\n\"readDir\": true,\n\"copyFile\": true,\n\"createDir\": true,\n\"removeDir\": true,\n\"removeFile\": true,\n\"renameFile\": true,\n\"exists\": true,\n\"scope\": [\"$DOCUMENT/**\"] // 접근할 디렉터리를 지정\n}\n}\n}\n}","scope-디렉터리-접근성#scope 디렉터리 접근성":"\"scope\": [\"$DOCUMENT/**\"]타우리는 사용자의 pc를 보호하기 위해 pc내 절대경로나 상위디렉터리 (../) 를 허용하지 않는다. 읽기 또는 쓰기가 가능한 디렉터리 스코프를 성정해줄때 위 옵션을 사용한다.문서폴더 외에 가능한 스코프는 여기를 참고하자.","readtextfile#readTextFile":"읽기 api들이 몇가지 있지만 문서작업시 필요한 데이터는 역시 텍스트 데이터다. 텍스트 읽기 함수의 시그니처와 사용예제는 다음과 같다.\nreadTextFile(filePath: string, options?: FsOptions): Promise<string>\n\nimport { readTextFile, BaseDirectory } from '@tauri-apps/api/fs';\nconst contents = await readTextFile(\n'path/file.json',\n{\tdir: BaseDirectory.Document }\n); // utf-8\n스코프에서 설정한 폴더는 BaseDirectory 이넘를 통해 접근가능하다.","writetextfile#writeTextFile":"쓰기 api도 읽기와 별반 다르지 않다.\nwriteTextFile(path: string, contents: string, options?: FsOptions): Promise<void>\n\nimport { writeTextFile, BaseDirectory } from '@tauri-apps/api/fs';\nawait writeTextFile(\n'app.conf',\n'file contents',\n{ dir: BaseDirectory.Document }\n);\n이쯤되면 패턴이 명확해서 더이상의 설명은 필요없을듯 하다","removefile#removeFile":"import { removeFile, BaseDirectory } from '@tauri-apps/api/fs';\nawait removeFile('app.conf', { dir: BaseDirectory.AppConfig });","readdir#readDir":"import { readDir, BaseDirectory } from '@tauri-apps/api/fs';\n\nconst entries = await readDir('users', { dir: BaseDirectory.AppData, recursive: true }); // 재귀함수로 하위 폴더와 디렉터리를 모두 가져온다.\n\nfunction processEntries(entries) {\nfor (const entry of entries) {\nconsole.log(`Entry: ${entry.path}`);\nif (entry.children) {\nprocessEntries(entry.children)\n}\n}\n}","removedir#removeDir":"import { removeDir, BaseDirectory } from '@tauri-apps/api/fs';\nawait removeDir('users', { dir: BaseDirectory.AppData });\n바이너리 파일 읽기 쓰기도 있지만 생략"}},"/programming/tips/regex_capturegroup":{"title":"정규표현식 캡쳐그룹","data":{"":"const relationString = `\n{\n\"list\": [\n{\n\"fromId\": \"test\",\n\"fromDirect\": \"b\",\n\"toId\": \"test2\",\n\"toDirect\": \"t\"\n},\n{\n\"fromId\": \"test2\",\n\"fromDirect\": \"b\",\n\"toId\": \"test4\",\n\"toDirect\": \"t\"\n},\n{\n\"fromId\": \"test\",\n\"fromDirect\": \"r\",\n\"toId\": \"test3\",\n\"toDirect\": \"l\"\n}\n],\n\"hash\": {\n\"test+test2\": true,\n\"test2+test4\": true,\n\"test+test3\": true\n}\n}\n`\n위와 같은 데이터가 있을 때 test 라는 문자열을 test1 으로 변경한다고 가정해보자.\n이때 이 데이터의 위치를 일일히 찾아서 수정하자니 코드가 복잡해진다. 해당 문서는 로컬파일로 저장되어있기때문에 어짜피 읽을때 문자열데이터로 읽어오니, 문자열 그 자체에서 변경할 수 있는 방법이 필요하다. 이때 그냥 자바스크립트의 replaceAll('test', 'test1') 함수를 사용한다면 test2 => test12 로 변경되는 불상사가 일어나게 된다.이럴때 정규표현식의 캡쳐그룹개념의 도움을 받으면 쉽게 수정할 수 있다.수정하려는 텍스트의 주변을 살펴보면 \" 또는 + 가 붙어있는것을 알 수 있는데, 이 특수문자를 캡쳐그룹으로 지정하고, 해당 텍스트를 변경한후 캡쳐그룹을 수정한텍스트 옆에 복원시켜주는 방식이다.사용된 정규표현식은 다음과 같다.\nconst regex =new RegExp(`([\"+])${beforeId}([\"+])`, 'g');\nconst newRelationString = relationString.replaceAll(regex, `$1${afterId}$2`)\n캡쳐그룹은 위와같이 [ ] 대괄호를 이용하여 사용한다. 대괄호안의 문자는 캡쳐그룹에 포함될 문자를 의미하며, 순서대로 1그룹 2그룹으로 지정된다. 복원할 캡쳐그룹은 2 표현을 통해 복원가능하다."}},"/programming/tips/usefull_info":{"title":"Usefull Info","data":{"":"이미지 레이지 로딩하는방법 : https://blog.webdevsimplified.com/2023-05/lazy-load-images\n링크 : https://www.youtube.com/watch?v=hJ7Rg1821Q0\n설명 : 'just trying to educate, feel free to leave a comment correcting me on anything or sharing your experiences.\n링크 : 'https://www.youtube.com/watch?v=oNmcX6Gozg0&t=3s'풀텍스트 서치에 관한 글\n퍼지파인딩\nhttps://www.mongodb.com/basics/full-text-search스프링부트 vscode 환경설정\nhttps://www.youtube.com/watch?v=ZNsEVrE9NW0"}}}